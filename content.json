{"meta":{"title":"Lappland","subtitle":"","description":"LapplandSP","author":"LapplandSP","url":"https://lapplandsp.github.io/LapplandSP","root":"/LapplandSP/"},"pages":[{"title":"友情链接","date":"2022-06-13T14:21:01.871Z","updated":"2022-06-13T14:21:01.871Z","comments":true,"path":"links/index.html","permalink":"https://lapplandsp.github.io/LapplandSP/links/index.html","excerpt":"","text":""}],"posts":[{"title":"使用Typora绘制图表","slug":"使用Typora绘制图表","date":"2022-06-17T18:47:50.000Z","updated":"2022-06-17T18:50:35.509Z","comments":true,"path":"2022/06/18/使用Typora绘制图表/","link":"","permalink":"https://lapplandsp.github.io/LapplandSP/2022/06/18/%E4%BD%BF%E7%94%A8Typora%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8/","excerpt":"","text":"使用 Typora 绘制图表 序列图 12345```sequenceAlice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks!``` 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 流程图 12345678910```flowst=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op``` 12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op Mermaid 序列图 12345678910111213```mermaid%% 这里是注释可以随便写 sequenceDiagram Alice-&gt;&gt;Bob: Hello Bob, how are you? alt is sick Bob-&gt;&gt;Alice: Not so good :( else is well Bob-&gt;&gt;Alice: Feeling fresh like a daisy end opt Extra response Bob-&gt;&gt;Alice: Thanks for asking end``` 1234567891011%% 这里是注释可以随便写 sequenceDiagram Alice-&gt;&gt;Bob: Hello Bob, how are you? alt is sick Bob-&gt;&gt;Alice: Not so good :( else is well Bob-&gt;&gt;Alice: Feeling fresh like a daisy end opt Extra response Bob-&gt;&gt;Alice: Thanks for asking end 流程图 1234567```mermaidgraph LRA[Hard edge] --&gt;B(Round edge) B --&gt; C&#123;Decision&#125; C --&gt;|One| D[Result one] C --&gt;|Two| E[Result two]``` 12345graph LRA[Hard edge] --&gt;B(Round edge) B --&gt; C&#123;Decision&#125; C --&gt;|One| D[Result one] C --&gt;|Two| E[Result two] “LR” 表示该流程图是从左（L）到右（R）的顺序生成 从上到下参数为 “TB” 树图 12345678910111213141516171819202122```mermaidgraph TBA((A))B((B))C((C))D((D))E((E))F((F))G((G))H((H))I((I))J((J)) K((K))A--&gt;BA--&gt;CA--&gt;DE--&gt;FG--&gt;HG--&gt;II--&gt;J``` 1234567891011121314151617181920graph TBA((A))B((B))C((C))D((D))E((E))F((F))G((G))H((H))I((I))J((J)) K((K))A--&gt;BA--&gt;CA--&gt;DE--&gt;FG--&gt;HG--&gt;II--&gt;J 其中，A((B))代表一个结点，A类似于key，而B类似于value。 甘特图 123456789101112131415161718192021222324252627282930```mermaid%% Example with selection of syntaxes gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page : 20h Add another diagram to demo page : 48h``` 12345678910111213141516171819202122232425262728%% Example with selection of syntaxes gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page : 20h Add another diagram to demo page : 48h 类图 1234567891011121314151617181920212223```mermaidclassDiagram Animal &lt;|-- Duck Animal &lt;|-- Fish Animal &lt;|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck&#123; +String beakColor +swim() +quack() &#125; class Fish&#123; -int sizeInFeet -canEat() &#125; class Zebra&#123; +bool is_wild +run() &#125;``` 123456789101112131415161718192021classDiagram Animal &lt;|-- Duck Animal &lt;|-- Fish Animal &lt;|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck&#123; +String beakColor +swim() +quack() &#125; class Fish&#123; -int sizeInFeet -canEat() &#125; class Zebra&#123; +bool is_wild +run() &#125; 状态图 12345678910```mermaidstateDiagram [*] --&gt; Still Still --&gt; [*] Still --&gt; Moving Moving --&gt; Still Moving --&gt; Crash Crash --&gt; [*]``` 12345678stateDiagram [*] --&gt; Still Still --&gt; [*] Still --&gt; Moving Moving --&gt; Still Moving --&gt; Crash Crash --&gt; [*] 饼图 1234567```mermaidpie title Pie Chart &quot;Dogs&quot; : 386 &quot;Cats&quot; : 85 &quot;Rats&quot; : 150 ``` 12345pie title Pie Chart &quot;Dogs&quot; : 386 &quot;Cats&quot; : 85 &quot;Rats&quot; : 150 Typora 官方帮助文档 内容来源于Typora 文档以及Mermaid 文档。 详细内容请查阅官方文档。","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://lapplandsp.github.io/LapplandSP/tags/Markdown/"}]},{"title":"数据结构-贰：表","slug":"数据结构-壹：线性表","date":"2022-06-14T15:22:26.000Z","updated":"2022-06-17T18:50:22.884Z","comments":true,"path":"2022/06/14/数据结构-壹：线性表/","link":"","permalink":"https://lapplandsp.github.io/LapplandSP/2022/06/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A3%B9%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"","text":"第二章 线性表 线性表定义（逻辑结构） 线性表是具有相同数据类型的n (n&gt;=0) 个数据元素的有限序列，其中 n 为表长，当n = 0时，线性表是一个空表。 其一般表示为： L = (a1 , a2, … , ai , ai+1 , an ) 几个概念： ai是线性标中的“第i个” 元素线性标中的位序（从1开始） a1是表头元素；an是表尾元素 除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继 线性表基本操作（运算） 创建、销毁、增删改查（所有数据结构适用的记忆思路） 判空、判长、打印输出等 其它: 传参何时引用“&amp;” 函数名易读 线性表的物理结构 1. 顺序表（顺序存储） 优点：可随机存取，存储密度高 缺点：要求大片连续空间，改变容量不方便 顺序表的定义 用顺序存储的方式实现线性表顺序存储。将逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素间的关系由存储单元的邻接关系来体现。 顺序表的实现 静态分配 “静态数组” 大小一旦确定便无法更改 动态分配 1234567#include &lt;stdlib.h&gt;#define InitSize 10typedef struct&#123; int *data; int MaxSize; int length;&#125; SeqList; 12345void InitList(SeqList &amp;L)&#123; L.data = (ElemType *)malloc(sizeof(ElemType) * InitSize); L.length = 0; L.MaxSize = InitSize;&#125; 123456789void IncreaseSize(SeqList &amp;L, int len)&#123; int *p = L.data; L.data = (int *)malloc((L.MaxSize + len) * sizeof(int)); for(int i = 0; i &lt; L.length; i++)&#123; L.data[i] = p[i]; //时间开销较大 &#125; L.MaxSize = L.MaxSize + len; free(p);&#125; 123456int main()&#123; SeqList L; InitList(L); IncreaseSize(L, 5); return 0;&#125; 顺序表的特点 随机访问，可以在 O(1) 时间内找到第 i 个元素。 存储密度高，每个节点只存储数据元素。 扩展容量不方便。（动态方式时间复杂度较高） 插入、删除操作不方便，需移动大量元素。 顺序表的基本操作 插入 ListInsert(&amp;L , i , e) 将插入位置之后的元素统一后移一格 平均时间复杂度 = O(n) ；最好 = O(1) ；最坏 = O(N) 1234567891011121314151617#define MaxSize 10typedef struct&#123; int data[MaxSize];//静态数组 int length;&#125;SeqList;bool ListInsert(SeqList &amp;L, int i, int e)&#123; if(i &lt;= 1 || i &gt; L.Lenth + 1) return false; if(L.length &gt;= MaxSize) return false; for(int j = L.length; j &gt;= i;j--) L.data[j] = L.data[j-1]; L.data[i-1] = e; L.length++; return true;&#125; 删除 ListDelete(&amp;L , i , &amp;e) 将删除位置之后的元素统一前移一格 平均时间复杂度 = O(n) ；最好 = O(1) ；最坏 = O(N) 123456789bool ListDelete(SqList &amp;L, int i, int &amp;e)&#123; if(i &lt; 1 || i &gt; L.lenth) return false; e = L.data[i - 1]; for (int j = 1; j &lt; L.lenth;j++) L.data[j-1] = L.data[j]; L.lenth--; return true;&#125; 12345678910int main()&#123; SqList L; InitList(L); int e = -1; if(ListDelete(L, 3, e)) printf(&quot;No.3 deleted, value = %d\\n&quot;, e); else printf(&quot;i is sb.&quot;); return 0;&#125; 代码要点 注意次序 i 和数组下标的关系 判断 i 的合法性 移动元素顺序 “&amp;”的使用 查找 按位查找 时间复杂度 = O(1) ，随机存取。 访问时，按照指针的数据类型大小计算跳跃距离。1234567891011122. 按值查找 ```c int LocalElem(SeqList L,ElemType e)&#123; for(int i = 0; i &lt; L.lenth ; i++)&#123; if(L.data[i] == e)&#123; return i+1; &#125; return 0; &#125; &#125; 对比结构体需要自己造轮子，不能直接用 “==” C++ 可以重载 “==” 时间复杂度：好 = O(1) ；坏 = O(n)；平均 = O(n) 2. 单链表（链式存储） 优点：不要求大片连续空间，改容量方便 缺点：不可随机存取，耗费一定空间存放指针 单链表的定义 123456789101112typedef struct LNode&#123; //结点 ElemType data; //数据域 Struct LNode *next; //指针域&#125;LNode, *LinkList;/*typedef struct LNode LNode;typedef struct LNode *LinkList;*/struct LNode *p = (struct LNode *)malloc(sizeof(struct LNode));LNode *L; //强调这是结点LinkList L; //强调这是单链表 初始化不带头结点的单链表: 123456789typedef struct LNode&#123; //结点 ElemType data; //数据域 Struct LNode *next; //指针域&#125;LNode, *LinkList;bool InitList(LinkList &amp;L)&#123; L = NULL; //空表判断 return true;&#125; 1234void test()&#123; LinkList L; InitList(L);&#125; 初始化带头结点的单链表: 1234567bool InitList(LinkList &amp;L)&#123; L = (LNode *)malloc(sizeof(LNode)); if (L==NULL) return false; L-&gt;next = NULL; //空表判断 return true;&#125; 不带头结点，头指针指向的结点是实际存储数据的头结点；带头结点是指向一个不存放数据的节点；带头结点写代码更方便，对第一个结点的操作逻辑与其他结点不同。 单链表的基本操作 插入 带头结点 1234567891011121314151617181920bool ListInsert(LinkList &amp;L, int i, ElemType e)&#123; if(i &lt; 1)&#123; return false; &#125; LNode *p; int j = 0; p = L; while(p != NULL &amp;&amp; j &lt; i - 1)&#123; p = p -&gt; next; j++; &#125; if(p == NULL)&#123; return false; &#125; LNode *s = (LNode *)malloc(sizeof(LNode)); s -&gt; data = e; s -&gt; next = p-&gt; next; p -&gt; next = s; return true;&#125; 不带头结点：插入位序为1时需要更改头指针 L 的指向，使其指向新结点。 删除 带头结点 1234567891011121314151617181920bool ListDelete(LinkList &amp;L, int i)&#123; if(i &lt; 1)&#123; return false; &#125; LNode *p; LNode *p2; int j = 0; p = L; while(p != NULL &amp;&amp; j &lt; i - 1)&#123; p2 = p; p = p -&gt; next; j++; &#125; if(p == NULL)&#123; return false; &#125; p2 -&gt; next = p -&gt; next; free(p); return true;&#125; 不带头结点：删除第一个结点时需要更改头指针的指向，使其指向第二个结点。 查找(带头结点) 按位查找 123456789101112LNode * GetElem(LinkList L, int i)&#123; if(1 &lt; 0)&#123; return NULL; &#125; LNode *p = L; int j = 0; while(p != NULL &amp;&amp; j &lt; i)&#123; p = p -&gt; next; j++; &#125; return p;&#125; 头结点为第零个结点，若i = 0 则返回头结点。 按值查找 1234567LNode * LocateELem(LinkList L ,ElemType e)&#123; LNode *p = L -&gt; next; while(p != NULL &amp;&amp; p -&gt; data != e)&#123; p = p -&gt; next; &#125; return p;&#125; 显然，最坏时间复杂度为 O(n) 求表长 12345678int Lenth(LinkList L)&#123; LNode *p = L -&gt; next; int len = 0; while(p != NULL)&#123; len++; &#125; return len;&#125; 最坏时间复杂度为O(n) 单链表的建立（带头结点） 结点 1234typedef struct LNode&#123; ElemType data; struct LNode *next;&#125;LNode, *LinkList; 尾插法（正向建立） 设置一个表尾指针，每次在尾部插入元素相当于是对表尾指针所指向的元素进行后插操作。 123456789101112131415161718LinkList List_TailInsert(LinkList &amp;L)&#123; int x; //设 ElemType 为 int 类型 scanf(&quot;%d&quot;,&amp;x); //输入结点值 L = (LNode *)malloc(sizeof(LNode)); //分配内存 //L = NULL LNode *s = L; //临时指针 LNode *z = L; //尾指针 while(x != 114514)&#123; //114514 为“安全词” s = (LNode *)malloc(sizeof(LNode)); //分配内存 s -&gt; data = x; //赋值 r -&gt; next = s; //r 还指向上一个结点，此处令上一个结点的 next 指向 s r = s; //令 r 指向最后一个结点 scanf(&quot;%d&quot;,&amp;x); //再次扫描 &#125; r -&gt; next = NULL; //尾结点 next 置空 return L; &#125; 头插法（逆向建立） 对头指针进行后插操作 123456789101112131415LinkList List_HeadInsert(LinkList &amp;L)&#123; int x; L = (LNode *)malloc(sizeof(LNode)); L -&gt; next = NULL; LNode *s; scanf(&quot;%d&quot;, &amp;x); while(x != 1919810)&#123; s = (LNode *)malloc(sizeof(LNode)); s -&gt; data = x; s -&gt; next = L -&gt; next; L -&gt; next = s; scanf(&quot;%d&quot;, &amp;x); &#125; return L;&#125; 3. 双链表 结点定义 与单链表的区别是双链表多了一个 prior 指针，指向上一个结点，形成双向的链式结构。 12345typedef struct DNode&#123; //&quot;D&quot; 指 &quot;double&quot; ElemType data; struct DNode *prior; //指向前驱结点 struct DNode *next;&#125;DNode, * DLinkList; 双链表建立 与单链表相似，要注意的是头结点的 prior 指针永远指向NULL。 双链表的基本操作 插入： 与单链表相同，但要让新结点的prior指向其下一个结点的前驱结点，再令下一个前驱结点的 prior 指向新结点本身。 函数传入两个参数（DNode *p, DNode *s）；指在 p 结点后插入 s 结点。 注意判断边界条件及参数合法性（NULL） 删除后继结点： 判断参数合法性，参数传入（DNode *p）；指删除 p 结点后的结点。 判断 p 是否有后继节点 判断 p 的后继节点是否有后继节点，以决定是否修改其prior指针。 free 销毁双链表 持续对头结点的 next 进行 删除后继结点 操作，直到其 next 为 NULL。 删除 头结点 L 。 遍历 1234567891011//后向遍历while(p != NULL)&#123; //func p = p -&gt; next;&#125;//前向遍历while(p != NULL)&#123; //func p = p -&gt; prior;&#125; 只处理数据节点可直接跳过头结点，判断条件改为（ p -&gt; next != NULL） 循环链表 分为循环单链表和循环双链表 再一次套娃，首尾相连。 静态链表 静态链表定义 分配一片连续的存储空间，结点集中存储，其游标充当指针的作用。 12345#define MaxSize 10typedef struct &#123; ElemType data; int next; //仅需存储下一个元素的数组下标&#125;SLinkList[MaxSize]; 其它 尾结点的指针值为 -1 找到某一位序结点的时间复杂度为O(n) 初始化应抹除脏数据 与OS 的文件分配表( FAT )关联 顺序表与链表的比较 顺序表 链表 容量弹性 就这？ NB 增、删 就这？ NB 查 NB 就这？ 开放式问题答题思路： Q：请描述顺序表和链表的#@%，实现线性表时，用顺序表还是链表好？ A： 逻辑结构都是线性结构 存储结构不同 +（各自特点、优缺点） 基本操作效率不同（初始化、增删改查） 结论","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lapplandsp.github.io/LapplandSP/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-壹：算法","slug":"数据结构-零：算法","date":"2022-06-14T15:21:42.000Z","updated":"2022-06-17T18:50:29.255Z","comments":true,"path":"2022/06/14/数据结构-零：算法/","link":"","permalink":"https://lapplandsp.github.io/LapplandSP/2022/06/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%B6%EF%BC%9A%E7%AE%97%E6%B3%95/","excerpt":"","text":"第一章 算法 1. 基本概念 程序 = 数据结构 + 算法 数据结构是要处理的信息 算法是处理信息的步骤 算法的五个特性 有穷性：一个算法必须在有穷步之后结束，且每一步的时间都是有穷的。 算法必须是有穷的，而程序可以是无穷的。 确定性： 算法中每条指令都必须有确切的含义，相同的输入对应得出相同的输出。 可行性： 算法中描述的操作都可以通过已经实现的基本运算执行有限次实现。 输入 输出 “好”算法的特点 正确性：能正确解决问题 可读性 健壮性：能处理异常情况 高效率与低存储量需求： 省时（低时间复杂度） 省内存（低空间复杂度） 2. 时间复杂度 计算 找到一个基本操作（最深层循环） 分析该基本操作的执行次数与问题规模n的关系 x = f(n) x 的数量级 O(x) 就是算法时间复杂度 T(n) 常用技巧 加法规则：O( f(n) ) + O( g(n) ) = O( max( f(n), g(n) ) ) 乘法规则：O(f(n)) * O(g(n)) = O( f(n) * g(n) ) O(1) &lt; O(log2n) &lt; O(n) &lt; O(n2) &lt; O(n3) &lt; O(2n) &lt; O(n!) &lt; O(nn) 常对幂指阶 顺序执行的代码只会影响常数项，可以忽略。 只需挑循环中的一个基本操作，分析他的执行次数与n的关系。 如果有多层嵌套循环，只需关注最深层循环循环了几次。 三种时间复杂度 最坏时间复杂度：考虑输入数据“最坏”的情况 平均时间复杂度：考虑所有输入数据都等概率出现的情况 最好时间复杂度：考虑输入数据“最好”的情况 3. 空间复杂度 计算 普通程序 找到所占空间大小与问题规模相关的变量 分析所占空间 x 与问题规模 n 的关系 x = f(n) x 的数量级 O(x) 就是算法空间复杂度 S(n) 递归程序 找到递归调用的深度 x 与问题规模 n 的关系 x = f(n) x 的数量级 O(x) 就是算法空间复杂度 S(n) 有的算法各层函数所需存储空间不同，分析方法略有区别 大部分递归调用都是 空间复杂度 = 递归调用的深度 常用技巧 加法规则、乘法规则、常对幂指阶 S(n) = O(1) 的常数阶算法可以原地工作","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lapplandsp.github.io/LapplandSP/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}],"categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://lapplandsp.github.io/LapplandSP/tags/Markdown/"},{"name":"数据结构","slug":"数据结构","permalink":"https://lapplandsp.github.io/LapplandSP/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}