{"meta":{"title":"Lappland","subtitle":"","description":"LapplandSP","author":"LapplandSP","url":"https://lapplandsp.github.io/LapplandSP","root":"/LapplandSP/"},"pages":[{"title":"友情链接","date":"2022-06-13T14:21:01.871Z","updated":"2022-06-13T14:21:01.871Z","comments":true,"path":"links/index.html","permalink":"https://lapplandsp.github.io/LapplandSP/links/index.html","excerpt":"","text":""}],"posts":[{"title":"【数据结构·四】 树与二叉树","slug":"【数据结构·四】树与二叉树","date":"2022-06-30T03:42:55.000Z","updated":"2022-06-30T03:43:41.196Z","comments":true,"path":"2022/06/30/【数据结构·四】树与二叉树/","link":"","permalink":"https://lapplandsp.github.io/LapplandSP/2022/06/30/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E5%9B%9B%E3%80%91%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"第五章 树与二叉树 树 树是n (n &gt; 0) 个结点的有限集合， n = 0 时，称为空树。 任意一个非空树应满足： 有且仅有一个特定的称为根的结点。 当 n &gt; 1 时，其余结点可分为m ( m &gt; 0 ) 个互不相交的有限集合，其中每个集合本身又是一棵树，称为根节点的子树。 基本概念 根结点：有且只有一个 边：“树干” 分支结点：有下一级分支的结点 叶子节点：没有下一级分支的结点 空树：结点数为 0 非空树 只有根节点没有前驱 只有叶子结点没有后继 除了根结点外，其余结点都有一个前驱，且只有一个前驱。 结点之间的关系 祖先结点、子孙结点、父结点、子结点、兄弟结点、堂兄弟结点 路径：只能从上往下，边是有向的。 路径长度：经过几条边 属性 层次（深度）：从上往下数（默认从1开始） 高度：从下往上数 树的高度/深度： 总共多少层 结点的度：有几个子分支 树的度：各节点中度的最大值 有序树：结点的各字树是有次序的 无序树 森林：m棵树互不相交组成的集合（允许空森林），可以与树相互转换 性质 结点数 = 总度数 + 1 度为 m 的树和 m 叉树的区别 度为m的树 m叉树 任意结点的度 &lt;= m （每个结点最多三个子结点） 任意结点的度 &lt;= m （每个结点最多三个子结点） 至少有一个结点度 = m 允许所有结点的度都 &lt; m 一定是非空树，至少有 m + 1 个结点 可以是空树 度为 m 的树的第 i 层 最多有 m^i-1 个结点（ i &gt;= 1） 第一层为根结点，为 m^0 ，以此类推 高度为 h 的 m 叉树至多有 ( m ^ h - 1 ) / ( m - 1 ) 个结点 等比数列 ( a + aq + aq^2 + aq^3 + ··· + aq^(n-1) ) 求和 高度为 h 的 m 叉树至少有 h 个结点。 高度为 h ，度为 m 的树至少有 h + m - 1 个结点。 具有 n 个结点的 m 叉树的最小高度为[ logm( n ( m - 1 ) + 1) ] 二叉树 二叉树定义 n ( n &gt;= 0) 个结点组成的有限集合，n = 0 时为空二叉树。 或者由一个根结点和左右两个子树组成，左右两个子树又分别是二叉树。 特殊二叉树 满二叉树 除叶子结点外，其余跟/分支结点都长满了两个分支。 有2h-1个结点 不存在度为1的结点 按层序编号，第i个结点的左子结点为2i，右子节点为2i - 1. 结点i的父结点为 \\lfloor i/2 \\rfloor 完全二叉树 当且仅当二叉树中结点与高度为h的满二叉树顺序编号后的1 ~ n个结点一一对应时，称为完全二叉树。 只可能在最后两层出现叶子结点 最多只有一个度为1的结点 父结点子结点方法与满二叉树相同 i &lt;= \\lfloor n/2 \\rfloor 时为分支结点，i &gt; \\lfloor n/2 \\rfloor 时为叶子结点 子结点一定是左子结点 二叉排序树 左子树所有关键字都小于根结点 右子树所有关键字都大于根结点 左右子树各是一颗二叉排序树 方便插入、查找 平衡二叉树 左子树和右子树深度差不超过1 希望树往宽处长 二叉树的性质 二叉树 设非空二叉树中度为0、1、2的结点个数分别为n0 , n1 , n2 ，则n0 = n2 + 1（叶子结点比二分支结点多一个） 节点总数为n，则： n = n0 + n1 + n2 （总和） n = n1 + 2n2 + 1 （一个子结点的子结点 + 两个子结点的子结点 + 根） 二叉树的第 i 层最多有 2i-1 个结点 （i &gt;= 1） m 叉树的第 i 层至多有 mi-1 个结点 （i &gt;= 1） 满二叉树 具有n个结点的完全二叉树的高度h为 \\lceil log2( n + 1 ) \\rceil 或 \\lfloor log2n \\rfloor + 1 （高为h的满二叉树结点数反过来算） 对于一个完全二叉树，可由结点数 n 推出度为0、1和2的结点个数n0 , n1 , n2 完全二叉树最多只有一个度为 1 的结点。 n0 = n2 + 1 ，n0 一定是偶数，所以 n0 + n2 一定是奇数 若是2k个结点： n0 = k, n2 = k - 1, n1 = 1 若是 2k - 1 个结点： n0 = k, n2 = k - 1, n1 = 0 二叉树的存储结构 顺序存储 直接存在数组里，从上至下，从左至右，结点只定义数据类型和是否为空。 123456789101112#define MaxSize 100struct TreeNode&#123; ElemType data; bool isEmpty;&#125;;TreeNode t[MaxSize]; //从上至下，从左至右;最好空出t[0];for(int i = 0; i &lt;= MaxSize; i++)&#123; t[i].isEmpty = true;&#125; i 的左子结点 2i；右子结点 2i + 1 i 的父结点 i/2 向下取整 i所在层次 log2( n + 1 ) 向上取整 判断 i 是否有左子结点： 2i 和 n 比，右子结点为 2i + 1和n比 判断它自己是不是子结点：i 和 n/2 比 普通二叉树编号与完全二叉树一一对应起来即可用顺序存储表示 浪费空间 所有顺序存储只适合存储完全二叉树 链式存储 12345678struct ElemType&#123; int value;&#125;;typedef struct BitNode&#123; ElemType data; struct BitNode *lchild, *rchild;&#125;BiTNode, *BiTree; 1234567891011121314BiTree root = NULL;// 插入根结点root = (BiTree) malloc (sizeof(BiTNode));root-&gt;data = &#123;1&#125;;root-&gt;lchild = NULL;root-&gt;rchild = NULL;// 插入新结点BiTNode * p = (BiTNode *) malloc (sizeof(BiTNode));p-&gt;data = &#123;2&#125;;p-&gt;lchild = NULL;p-&gt;rchild = NULL;root-&gt;lchild = p; 三叉链表 —— 多加一个指向父结点的指针 遍历 先序：根左右 NLR 中序：左根右 LNR 后序：左右根 LRN 递归遍历： 1234567void PreOrder(BiTree T)&#123; //先序遍历 if(T!=NULL)&#123; visit(T); PreOrder(T-&gt;lchild); PreOrder(T-&gt;rchild); &#125;&#125; 中、后序，仅visit位置不同 空间复杂度 O(h) 层序遍历 初始化辅助队列 根入队 若队列非空，则队头出队，访问该结点，并将其左右子结点按顺序入队 重复，直至队列为空 1234567891011121314void LevelOrder(BiTree T)&#123; LinkQueue Q; InitQueue(Q); BiTree p; EnQueue(Q,T); while(!isEmpty(Q))&#123; DeQueue(Q, p); visit(p); if(p_&gt;lchild!=NULL) EnQueue(Q,p-&gt;lchild); if(p-&gt;rchild!=NULL) EnQueue(Q,p-&gt;rchild); &#125;&#125; 由遍历序列构造二叉树 只给一种无法确定 要确定，需要前/后/层 + 中 线索二叉树 中序线索二叉树：叶子节点左指针指向中序遍历的前驱，右指针则指向后继 ，最后一个结点右指针及第一个结点左指针指向NULL 中序前驱 中序后继 存两个tag用来表示指针是否是线索 先序 先序前驱 先序后继 后序 后序前驱 后序后继 12345678910111213141516171819void InThread(ThreadTree T)&#123; if(T!=NULL)&#123; InThread(T-&gt;lchild); visit(T); InThread(T-&gt;rchild); &#125;&#125; void visit(ThreadNode *q)&#123; if(q-&gt;lchild==NULL)&#123; q-&gt;lchild = pre; q-&gt;ltag = 1; &#125; if(pre!=NULL &amp;&amp; pre-&gt;child ==NULL)&#123; pre-&gt;rchild = q; pre-&gt;rtag = 1; &#125; pre = q;&#125; 找中序二叉树的前驱后继 中序线索二叉树找中序后继 tag = 1 为已线索化 若 p-&gt;rtag == 1, 则 next = p -&gt; rchild 若 p-&gt;rtag == 0, 则 next = p 右子树中最左下的结点 123456789101112131415161718ThreadNode *FirstNode(ThreadNode *p)&#123; //一直往左找 while(p-&gt;ltag == 0)&#123; p = p -&gt; lchild; &#125; return p;&#125;ThreadNode *NextNode(ThreadNode *p)&#123; //判断右指针是否指向子树 if(p -&gt; rtag == 0)&#123; return FirstNode(p-&gt;rchild); &#125; else return p -&gt; rchild;&#125;//非递归遍历 O(1)void InOrder(ThreadNode *T)&#123; for(ThreadNode *p = FirstNode(T);p!=NULL;p = p-&gt;NextNode(p)) visit(p);&#125; 找中序前驱 若 p-&gt;rtag == 1, 则 pre = p -&gt; lchild 若 p-&gt;rtag == 0, 则 pre = p 左子树中最右下的结点 12345678ThreadNode LastNode(ThreadNode *p)//找二叉树最右下角结点ThreadNode *PreNode(ThreadNode *p)&#123; if(p -&gt; ltag == 0)&#123; //如果是树就找最右下角 return LastNode(p-&gt;lchild); &#125; //如果不是树就是线索，直接返回 else return p -&gt; rchild;&#125; 先序线索二叉树找先序后继 右指针指向树，则后继为该树的根结点 右指针直接指向后继 找先序前驱 左指针直接指向前驱 指的不是前驱，没法找，只能遍历 除非是三叉链表 结点为左子树，父结点就是前驱 结点为右子树且左兄弟为空，父结点就是前驱 结点为右子树且做兄弟非空，前驱为其左兄弟向最右下走，没路了往左走，只要有右子树就往右走，走到没路为止。 p是根结点：没有先序前驱 后序线索二叉树找后序前驱 右指针指向右子树，右指针指向结点即为前驱 左指针是线索，直接指向前驱 右指针是线索或为空，左子树的根为前驱 找后续后继 无三叉链表只能遍历 结点为右子树，后继为父结点 结点为左子树且右兄弟为空，后继为父结点 结点为左子树且右子树非空，后继为右子树第一个被访问结点 结点为根结点，无后继 树的逻辑结构 父结点表示法（顺序存储） 每个结点中保存指向双亲的“指针” 12345678910#define MAX_TREE_SIZE 100typedef struct&#123; ElemType data; int parent;&#125;PTNode;typedef struct&#123; PTNode nodes[MAX_TREE_SIZE]; int n;&#125;PTree; 增加：直接在数组中增加 删除： 若是叶子节点：直接把下面的移上去覆盖掉（更好） 或者把要删除的结点父指针指向 -1 结点数n–； 若不是叶子节点，需遍历判断。 子结点表示法（顺序 + 链式存储） 顺序存储各个节点，每个结点保存子结点链表头指针。链表里存的是子结点在数组中的位序。 子结点 + 兄弟结点表示法（链式存储） 结点为二叉结点，左指针指向第一个子结点；右指针指向右侧兄弟节点。 可将树转化为二叉树 可用二叉树操作来处理树 森林和树的转化 从根节点出发，包括子树在内所有右路节点均为平行关系 树的遍历 先根遍历 若树非空，则先访问根结点，再依次对每棵子树进行先根遍历。 后根遍历 若树非空，先依次对每棵子树进行后根遍历，最后再访问根结点。 层次遍历（队列实现） 若树非空，根结点入队 若队列非空，队头出队并访问，同时将子结点依次入队 直到队列为空 先根、后根都是深度优先，层次为广度优先 森林的遍历 先序遍历森林 若森林非空： 访问森林中第一棵树的根结点 先序遍历第一棵树中根节点的子树森林 先序遍历其他的 或将其转化为对应的二叉树 中序遍历森林 把森林转化为二叉树后对二叉树进行中序遍历，而不是中序遍历森林 这其实是对森林中每一棵树的后序遍历","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lapplandsp.github.io/LapplandSP/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"【数据结构·C】 KMP算法","slug":"【数据结构·C】KMP算法","date":"2022-06-19T07:02:42.000Z","updated":"2022-06-19T07:04:02.112Z","comments":true,"path":"2022/06/19/【数据结构·C】KMP算法/","link":"","permalink":"https://lapplandsp.github.io/LapplandSP/2022/06/19/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7C%E3%80%91KMP%E7%AE%97%E6%B3%95/","excerpt":"","text":"KMP算法 模式匹配 在主串中找到与模式串相同的子串，并返回其所在位置。 朴素模式匹配算法 从第一个字符开始，将主串中”从当前字符开始的长度与模式串相同的子串“与 子串 相比较。 123456789101112131415161718int Index(SString S, SString T)&#123; int k = 1; int i = k, j = 1; while(i &lt;= S.lenth &amp;&amp; j &lt;= T.lenth)&#123; if(S.str[i] == T.str[j])&#123; i++; j++; &#125;else&#123; k++; i = k; j = 1; &#125; &#125; if(j &gt; T.lenth) return k; else return 0;&#125; 特性 匹配成功的最好时间复杂度：O( m ) 匹配失败的最好时间复杂度：O( n - m + 1 ) = O( n - m ) =O( n ) 最坏时间复杂度：O( mn ) KMP算法 主串扫描指针不回溯 匹配失败时模式串扫描指针回溯 指针回溯策略： 定义与模式串相同长度的 next 数组 当第一个字符就不匹配时，应让 j 指向0，下一次循环时，i j都自增，此时j指向子串的第一个字符，而 i 后移一位以继续进行匹配。 1234567891011121314151617int Index_KMP(SString S, SString T)&#123; int i = 1, j = 1; while(i &lt;= S.lenth &amp;&amp; j &lt;= T.lenth)&#123; if(j == 0 || S.str[i] == T.str[i])&#123; ++i; ++j; //继续比较后继字符 &#125;else&#123; j = next[j]; //相当于模式串右移 &#125; &#125; if(j &gt; T.lenth) return i - T.lenth; else return 0;&#125; 求 next 数组 next[1] = 0; 当第 j 个字符匹配失败，由前 1 到 j - 1 个字符组成的串记为 S，则 next[j] = S相等的前后缀长度 + 1 平均时间复杂度O( n + m ) 考试中一般为手算 next 数组 优化的KMP算法 经典KMP算法中，主串中的 i 与 j 不匹配时，j 会指向 next[j] 以将子串右移。 经典的 next 数组算法，仅考虑前后字符串匹配问题。 当 j 与 next[j] 相同时，会多出无意义的对比，应对 next 数组进行优化。 求 nextval 数组 当 j == next[j] 时，可将 j 指向 next[j] 的 next. 序号j 1 2 3 4 5 6 模式串 G O O G L E next[j] 0 1 1 1 2 1 nextval[j] 0 1 1 0 2 1","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lapplandsp.github.io/LapplandSP/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"【数据结构·三】 串","slug":"【数据结构·三】 串","date":"2022-06-19T05:54:04.000Z","updated":"2022-06-19T05:54:51.713Z","comments":true,"path":"2022/06/19/【数据结构·三】 串/","link":"","permalink":"https://lapplandsp.github.io/LapplandSP/2022/06/19/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E4%B8%89%E3%80%91%20%E4%B8%B2/","excerpt":"","text":"串 串的定义 串即字符串，有零个或多个字符组成的有限序列。 S = ‘a1a2a3…an’ (n &gt; 0) S 为串名 边界符为引号或括号 字符序列为串值 n为串的长度 n = 0时为空串 串是一种线性表，数据元素之间呈线性关系。 基本操作通常以子串为操作对象。 名词 子串 串中任意个连续字符组成的子序列。 主串 包含字串的串 字符在主串中的位置 字符在串中的序号。（从1开始数） 子串在主串中的位置 第一个字符在主串中的位置。 串的基本操作 12345678910111213141516171819202122232425```StrCopy(&amp;T,S)```复制```StrEmpty(S)```拷贝```StrLength(S)```求串长```ClearString(&amp;S)```清空```DestroyString(&amp;S)```销毁```Concat(&amp;T,S1,S2)```串连接```SubString(&amp;Sub, S, pos,len)```求子串：将串 S 从第 pos 个字符开始，长度为 len 的字符串赋值给Sub。```cbool SubString(SString &amp;Sub, SString S, int pos, int len)&#123; if(pos + len - 1 &gt; S.lenth) return false; for(int i = pos; i &lt; pos + len; i++)&#123; Sub[i - pos + 1] = S.str[i]; Sub.lenth = len; return true; &#125;&#125; T)```定位子串123456789101112```cint Index(SString S, SString T)&#123; int i = 1, n = S.lenth, m = T.lenth; SString sub; //暂存字串 while(i &lt; n - m + 1)&#123; SubString(sub,S,i,m); if(StrCompare(sub, T) != 0) ++i; else return i; &#125; return 0; //找不到子串&#125; 定位操作的进阶算法：朴素模式匹配算法 -&gt; KMP算法 -&gt; 优化的KMP算法 T)```比较长度123456789```cint StrCompare(SString S, SString T)&#123; //由正、负、零来判断大小 for (int i = 1 ; i &lt;= S.lenth &amp;&amp; i &lt;= T.lenth; i++)&#123; if(S.str[i] != T.str[i]) return S.str[i] - T.str[i]; &#125; return S.lenth - T.lenth;&#125; 串的顺序存储 用数组 在最后一位存储串的长度 牺牲第一个空间，保证串的位序与数组下标相同。 串的链式存储 每个结点存储多个字符（最好是四个） 若每个结点存一个字符，存储密度低（每个结点 = 1字节数据 + 4字节指针） 1234typedef struct StringNode&#123; char str[4]; struct StringNode *next;&#125;StringNode, *String; 可将空闲空间由&quot;\\0&quot;填充。","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lapplandsp.github.io/LapplandSP/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"【数据结构·B】 矩阵的压缩存储","slug":"【数据结构·B】 矩阵的压缩存储","date":"2022-06-18T10:46:58.000Z","updated":"2022-06-18T11:37:51.312Z","comments":true,"path":"2022/06/18/【数据结构·B】 矩阵的压缩存储/","link":"","permalink":"https://lapplandsp.github.io/LapplandSP/2022/06/18/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7B%E3%80%91%20%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8/","excerpt":"","text":"矩阵的压缩存储 预备内容 内存中二维数组的线性存储方法： 行优先：一行一行存，存完一行存下一行； b[i][j]的存储地址 = LOC(起始地址) + (i * N + j) * sizeof(ElemType) 列优先：一列一列存，存完一列存下一列。 b[i][j]的存储地址 = LOC(起始地址) + (j * M + i) * sizeof(ElemType) 对称矩阵 n阶方阵中任意一个元素都有a[i][j] = a[j][i]，则该矩阵为对称矩阵。 普通存储： n*n 策略 只存储主对角线+下三角区。 按行优先原则将各元素存入一维数组中 数组大小为 (1 + n) * n / 2 可设计映射函数将二维坐标转义为线性位序 k = i*(i - 1)/2 + j -1 (i &gt; j) 三角矩阵 除了主对角线和下三角区，其余的元素都相同。 策略 多一个存储单元存储相同的元素，一般放在最后面 k = i*(i - 1)/2 + j -1 (i &gt; j) n * (n - 1) / 2 (i &lt; j) 三对角矩阵 带状矩阵，当|i - j | &gt; 1时a[i][j] = 0 策略 除了第一行和最后一行外，每行都是三个元素。[0] - [3n - 3] k = 2i + j - 3 稀疏矩阵 非零元素远少于矩阵元素个数 策略 顺序存储 三元组（行、列、值） 失去随机存储特性 链式存储 十字链表法 链表中存储矩阵的行、列； 向右域存储列 向下域存储行","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lapplandsp.github.io/LapplandSP/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"【数据结构·A】栈与队列的应用","slug":"【数据结构·A】栈与队列的应用","date":"2022-06-18T09:46:31.000Z","updated":"2022-06-18T11:37:43.812Z","comments":true,"path":"2022/06/18/【数据结构·A】栈与队列的应用/","link":"","permalink":"https://lapplandsp.github.io/LapplandSP/2022/06/18/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7A%E3%80%91%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"栈与队列的应用 1. 括号匹配（栈） 遇到左括号就入栈，遇到右括号就弹出（大、中、小括号应匹配） 只有左括号，没有右括号，报错。 有右括号，但栈空，报错。 弹出的左括号与右括号不匹配，报错。 12345#define MaxSize 20typedef struct&#123; char data[MaxSize]; int top;&#125; SqStack; 1234567891011121314151617181920212223bool BracketCheck(char str[], int lenth)&#123; SqStack S; InitStack(S); for(int i = 0; i &lt; lenth; i++ )&#123; if(str[i] == &quot;(&quot; || str[i] == &quot;[&quot; || str[i] == &quot;&#123;&quot;)&#123; return false; &#125;else&#123; if(StackEmpty(S)) return false; char topChar; pop(S, topChar); if(str[i] == &quot;(&quot; &amp;&amp; topChar != &quot;)&quot;) return false; if(str[i] == &quot;[&quot; &amp;&amp; topChar != &quot;]&quot;) return false; if(str[i] == &quot;&#123;&quot; &amp;&amp; topChar != &quot;&#125;&quot;) return false; &#125; &#125; return StackEmpty(S);&#125; 可以直接使用基本操作，但要注释说明接口 1234567891011//初始化栈void InitStack(SqStack &amp;S) //判断空栈bool StackEmpty(SqStack S) //压栈bool Push(SqStack &amp;S, char x)//出栈bool Pop(SqStack &amp;S, char &amp;x) 2. 表达式求值（栈） 中缀表达式 前缀表达式 （波兰表达式） 后缀表达式 （逆波兰表达式） 名词 操作数：数字 / 变量 界限符：括号 运算符：加减乘除 语法 中缀表达式 后缀表达式 前缀表达式 a + b a b + + a b a + b - c a b + c - - + a b c a + b - c * d a b + c d * - - + a b * c d 原则 左优先原则：只要有靠近左边的运算符可以运算， 就优先生效左边的运算符。 可保证运算顺序唯一。 中缀表达式转后缀表达式 初始化栈，保存暂时不能确定运算顺序的运算符。 遇到操作数，直接加入后缀表达式。 遇到界限符，遇到左括号 “(” 直接入栈，遇到右括号 “)” 依次弹出栈内运算符并加入后缀表达式，直到弹出左括号 “(” 为止，左括号不入栈。 遇到运算符，依次弹出栈中优先级高于或等于该运算符的所有运算符，加入后缀表达式，直到栈空或遇到左括号为止，再将此运算符入栈。 以上述方法处理完所有字符后，将剩余运算符依次弹出，加入后缀表达式。 后缀表达式计算 从左往右扫描下一个元素，直到处理完所有元素。 扫描到操作数则入栈。 扫描到运算符则弹出位于栈顶的两个操作数，运算结果压回栈顶。 中缀表达式计算 初始化两个栈，一个存操作数，一个存运算符。 扫描到操作数，压入栈。 扫描到运算符，依次弹出栈中优先级高于或等于该运算符的所有运算符，加入后缀表达式，直到栈空或遇到左括号为止，再将此运算符入栈。每弹出一个运算符都需要弹出两个操作数执行计算，并将结果压回栈中。 3. 递归（栈） 递归算法效率很低。 在递归调用的过程中，系统为每一层的返回点、局部变量、传入实参等等都开辟了递归工作栈来进行数据存储。 递归次数多容易造成栈溢出。 递归算法可能包含多次重复运算。 可以将递归算法转换为非递归算法，通常需要借助栈来实现。 4. 树的层次遍历（队列） 将根结点入队。 处理队头元素，若有子节点则全部入队，最后该结点出队。 以此可以完成树的层次遍历。 5. 图的广度优先遍历（队列） 创建队列 从第一个结点开始遍历，将与其相邻的所有未遍历过的结点全部入队。 处理队头元素，将与其相邻的所有未遍历过的结点全部入队。 以此完成图的广度优先遍历。 6. 操作系统 先来先服务 First come first service (FCFS)","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lapplandsp.github.io/LapplandSP/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"【数据结构·二】栈、队列和数组","slug":"【数据结构·二】栈、队列和数组","date":"2022-06-18T07:45:40.000Z","updated":"2022-06-18T07:46:17.997Z","comments":true,"path":"2022/06/18/【数据结构·二】栈、队列和数组/","link":"","permalink":"https://lapplandsp.github.io/LapplandSP/2022/06/18/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E4%BA%8C%E3%80%91%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84/","excerpt":"","text":"第三章 栈、队列和数组 栈 栈的定义 栈（stack）是一种仅允许在一端（栈顶）进行插入或删除操作的线性表。 名词 栈顶：允许插入和删除的一端 栈底：不允许插入和删除的一端 空栈：栈中没有元素 特点 先进后出：Last in first out (LIFO) 栈的基本操作 创建与销毁 创建：InitStack(&amp;S) 销毁：DestroyStack(&amp;S) 增、删 增（压栈）：push(&amp;S, x) 删（出栈）：pop(&amp;S, &amp;x) 出栈时会返回栈顶结点值 查 读栈顶：GetTop(S, &amp;x) 判空：StackEmpty(S) 判断栈S是否为空，返回布尔值 顺序栈的实现（顺序存储） 顺序栈的定义 1234typedef struct&#123; ElemType data[MaxSize]; int top; //栈顶指针（数组下标）&#125;SqStack; 顺序栈基本操作 12345678910111213141516171819202122232425262728293031void InitStack(SqStack &amp;S)&#123; S.top = -1; //可初始化为0，此时push与pop操作将直接对top所指向位置进行操作。 /*可以抹除脏数据*/&#125;bool push(SqStack &amp;S, ElemType x)&#123; if(S.top == MaxSize -1)&#123; return false; &#125; S.top = S.top +1; S.data[top] = x; return true;&#125;bool pop(SqStack &amp;S, ElemType &amp;x)&#123; if(S.top == -1)&#123; return false; &#125; x = S.data[S.top]; S.data[S.top] = 0; S.top = S.top -1; return true;&#125;bool GetTop(SqStack &amp;S, ElemType &amp;x)&#123; if(S.top == -1)&#123; return false; &#125; x = S.data[S.top]; return true;&#125; 共享栈（顺序存储） 共享栈可以存储两串数据，分别从栈的两端向内相向存储，栈顶在内侧，top指针相同时两个栈均为满栈。 链栈的实现（链式存储） 链栈定义 1234typedef struct LinkNode&#123; ElemType data; struct LinkNode *next;&#125;LiStackNode, *LiStack; 链栈基本操作 链栈的基本操作与单链表几乎相同，区别在于链栈仅允许在栈顶进行插入与删除。 推荐使用不带头结点方式，栈顶指针来指向栈顶元素。 12345678910111213141516171819LiStack InitStack()&#123; LiStackNode* top = (LiStackNode*)malloc(sizeof(ListackNode)); if(top == NULL) return flase; top -&gt; next = NULL; return true;&#125;bool push(LiStack top, ElemType x)&#123; LiStackNode *p = (LiStackNode *)malloc(sizeof(LiStackNode)); if(p == NULL) return false; p -&gt; data = x; p -&gt; next = top -&gt; next; top -&gt; next = p; return true&#125;//etc. 队列 队列的定义 队列（queue）是只允许在队列的一端进行插入（入队），另一端进行删除（出队）的线性表。 名词 队头：删除的一端为队头 队尾：插入的一段为队尾 空队列：对头 == 队尾 特点 先进先出：First in first out (FIFO) 队列的基本操作 创建与销毁 创建：InitQueue(&amp;Q) 销毁：DestroyQueue(&amp;Q) 增、删 增（入队）：Enqueue(&amp;Q, x) 删（出队）：Dequeue(&amp;Q, &amp;x) 出队时会返回队头结点值 查 读队列顶：GetTop(Q, &amp;x) 判空：QueueEmpty(Q) 判断栈S是否为空，返回布尔值 队列的实现（顺序存储） 顺序队列的定义 需要有两个指针指向队头队尾 12345#define MaxSize 20typedef struct&#123; ElemType data[MaxSize]; int front, rear;&#125;SqQueue; //sequence 顺序队列的基本操作 初始化 123void InitQueue(SqQueue &amp;Q)&#123; Q.rear = Q.front = 0;&#125; 判空：队头指针 == 队尾指针 入队：元素插入队尾 队尾指针后移 123456789![image-20220618150319668](https://blog-lappland.oss-cn-hangzhou.aliyuncs.com/img/image-20220618150319668.png)**循环队列中应牺牲一个存储单元，使得rear != front ，以免影响判空。- 出队 ```c Q.front= (Q.front + 1) % MaxSize 取队头元素 直接读取队头指针处的值。 扩展 可以在顺序队列中定义变量 size ，存储队列长度，并以此为判空依据。 可以在顺序队列中定义变量 tag ，每次删除成功都令其为0，每次插入成功令其为1，以 tag 值为判空依据。 队列的实现（链式存储） 链式队列为单链表的阉割版 链式队列定义 1234567typedef struct LinkNode&#123; ElemType data; struct LinkNode * next;&#125;LinkNode;typedef struct LinkQueue&#123; LinkNode *front, *rear;&#125;LinkQueue; 链式队列基本操作 初始化 带头结点：front 与 rear 同时指向头结点，front 的 next （即头结点的next）指向NULL 不带头结点：直接全指向NULL 入队 新结点的 next 一定是 NULL 队尾结点 next 先指向新结点，新结点 next 指向NULL 不带头结点需要判断是否为第一个元素 出队 判空 判断是否为最后一个结点出队，若是则将rear = front（不带头结点直接全部指向NULL） free 扩展 可以加入 lenth 变量记录其长度。 链式队列除非内存空间已满，否则不会满。 双端队列 允许两端的插入和删除。 输入受限的双端队列 输出受限的双端队列 双端队列考点 输出顺序是否合法","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lapplandsp.github.io/LapplandSP/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"使用Typora绘制图表","slug":"使用Typora绘制图表","date":"2022-06-17T18:47:50.000Z","updated":"2022-06-17T18:50:35.509Z","comments":true,"path":"2022/06/18/使用Typora绘制图表/","link":"","permalink":"https://lapplandsp.github.io/LapplandSP/2022/06/18/%E4%BD%BF%E7%94%A8Typora%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8/","excerpt":"","text":"使用 Typora 绘制图表 序列图 12345```sequenceAlice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks!``` 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 流程图 12345678910```flowst=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op``` 12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op Mermaid 序列图 1234567891011&lt;pre class=&quot;mermaid&quot;&gt; %% 这里是注释可以随便写 sequenceDiagram Alice-&gt;&gt;Bob: Hello Bob, how are you? alt is sick Bob-&gt;&gt;Alice: Not so good :( else is well Bob-&gt;&gt;Alice: Feeling fresh like a daisy end opt Extra response Bob-&gt;&gt;Alice: Thanks for asking end&lt;/pre&gt; %% 这里是注释可以随便写 sequenceDiagram Alice->>Bob: Hello Bob, how are you? alt is sick Bob->>Alice: Not so good :( else is well Bob->>Alice: Feeling fresh like a daisy end opt Extra response Bob->>Alice: Thanks for asking end 流程图 12345&lt;pre class=&quot;mermaid&quot;&gt; graph LRA[Hard edge] --&gt;B(Round edge) B --&gt; C&#123;Decision&#125; C --&gt;|One| D[Result one] C --&gt;|Two| E[Result two]&lt;/pre&gt; graph LR A[Hard edge] -->B(Round edge) B --> C{Decision} C -->|One| D[Result one] C -->|Two| E[Result two] “LR” 表示该流程图是从左（L）到右（R）的顺序生成 从上到下参数为 “TB” 树图 1234567891011121314151617181920&lt;pre class=&quot;mermaid&quot;&gt; graph TBA((A))B((B))C((C))D((D))E((E))F((F))G((G))H((H))I((I))J((J)) K((K))A--&gt;BA--&gt;CA--&gt;DE--&gt;FG--&gt;HG--&gt;II--&gt;J&lt;/pre&gt; graph TB A((A)) B((B)) C((C)) D((D)) E((E)) F((F)) G((G)) H((H)) I((I)) J((J)) K((K)) A-->B A-->C A-->D E-->F G-->H G-->I I-->J 其中，A((B))代表一个结点，A类似于key，而B类似于value。 甘特图 12345678910111213141516171819202122232425262728&lt;pre class=&quot;mermaid&quot;&gt; %% Example with selection of syntaxes gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page : 20h Add another diagram to demo page : 48h&lt;/pre&gt; %% Example with selection of syntaxes gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page : 20h Add another diagram to demo page : 48h 类图 123456789101112131415161718192021&lt;pre class=&quot;mermaid&quot;&gt; classDiagram Animal &lt;|-- Duck Animal &lt;|-- Fish Animal &lt;|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck&#123; +String beakColor +swim() +quack() &#125; class Fish&#123; -int sizeInFeet -canEat() &#125; class Zebra&#123; +bool is_wild +run() &#125;&lt;/pre&gt; classDiagram Animal Moving Moving --> Still Moving --> Crash Crash --> [*] 饼图 12345&lt;pre class=&quot;mermaid&quot;&gt; pie title Pie Chart &quot;Dogs&quot; : 386 &quot;Cats&quot; : 85 &quot;Rats&quot; : 150&lt;/pre&gt; pie title Pie Chart \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 150 Typora 官方帮助文档 内容来源于Typora 文档以及Mermaid 文档。 详细内容请查阅官方文档。","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://lapplandsp.github.io/LapplandSP/tags/Markdown/"}]},{"title":"【数据结构·一】 线性表","slug":"【数据结构·一】 线性表","date":"2022-06-14T15:22:26.000Z","updated":"2022-06-18T07:47:31.089Z","comments":true,"path":"2022/06/14/【数据结构·一】 线性表/","link":"","permalink":"https://lapplandsp.github.io/LapplandSP/2022/06/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E4%B8%80%E3%80%91%20%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"","text":"第二章 线性表 线性表定义（逻辑结构） 线性表是具有相同数据类型的n (n&gt;=0) 个数据元素的有限序列，其中 n 为表长，当n = 0时，线性表是一个空表。 其一般表示为： L = (a1 , a2, … , ai , ai+1 , an ) 几个概念： ai是线性标中的“第i个” 元素线性标中的位序（从1开始） a1是表头元素；an是表尾元素 除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继 线性表基本操作（运算） 创建、销毁、增删改查（所有数据结构适用的记忆思路） 判空、判长、打印输出等 其它: 传参何时引用“&amp;” 函数名易读 线性表的物理结构 1. 顺序表（顺序存储） 优点：可随机存取，存储密度高 缺点：要求大片连续空间，改变容量不方便 顺序表的定义 用顺序存储的方式实现线性表顺序存储。将逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素间的关系由存储单元的邻接关系来体现。 顺序表的实现 静态分配 “静态数组” 大小一旦确定便无法更改 动态分配 1234567#include &lt;stdlib.h&gt;#define InitSize 10typedef struct&#123; int *data; int MaxSize; int length;&#125; SeqList; 12345void InitList(SeqList &amp;L)&#123; L.data = (ElemType *)malloc(sizeof(ElemType) * InitSize); L.length = 0; L.MaxSize = InitSize;&#125; 123456789void IncreaseSize(SeqList &amp;L, int len)&#123; int *p = L.data; L.data = (int *)malloc((L.MaxSize + len) * sizeof(int)); for(int i = 0; i &lt; L.length; i++)&#123; L.data[i] = p[i]; //时间开销较大 &#125; L.MaxSize = L.MaxSize + len; free(p);&#125; 123456int main()&#123; SeqList L; InitList(L); IncreaseSize(L, 5); return 0;&#125; 顺序表的特点 随机访问，可以在 O(1) 时间内找到第 i 个元素。 存储密度高，每个节点只存储数据元素。 扩展容量不方便。（动态方式时间复杂度较高） 插入、删除操作不方便，需移动大量元素。 顺序表的基本操作 插入 ListInsert(&amp;L , i , e) 将插入位置之后的元素统一后移一格 平均时间复杂度 = O(n) ；最好 = O(1) ；最坏 = O(N) 1234567891011121314151617#define MaxSize 10typedef struct&#123; int data[MaxSize];//静态数组 int length;&#125;SeqList;bool ListInsert(SeqList &amp;L, int i, int e)&#123; if(i &lt;= 1 || i &gt; L.Lenth + 1) return false; if(L.length &gt;= MaxSize) return false; for(int j = L.length; j &gt;= i;j--) L.data[j] = L.data[j-1]; L.data[i-1] = e; L.length++; return true;&#125; 删除 ListDelete(&amp;L , i , &amp;e) 将删除位置之后的元素统一前移一格 平均时间复杂度 = O(n) ；最好 = O(1) ；最坏 = O(N) 123456789bool ListDelete(SqList &amp;L, int i, int &amp;e)&#123; if(i &lt; 1 || i &gt; L.lenth) return false; e = L.data[i - 1]; for (int j = 1; j &lt; L.lenth;j++) L.data[j-1] = L.data[j]; L.lenth--; return true;&#125; 12345678910int main()&#123; SqList L; InitList(L); int e = -1; if(ListDelete(L, 3, e)) printf(&quot;No.3 deleted, value = %d\\n&quot;, e); else printf(&quot;i is sb.&quot;); return 0;&#125; 代码要点 注意次序 i 和数组下标的关系 判断 i 的合法性 移动元素顺序 “&amp;”的使用 查找 按位查找 时间复杂度 = O(1) ，随机存取。 访问时，按照指针的数据类型大小计算跳跃距离。1234567891011122. 按值查找 ```c int LocalElem(SeqList L,ElemType e)&#123; for(int i = 0; i &lt; L.lenth ; i++)&#123; if(L.data[i] == e)&#123; return i+1; &#125; return 0; &#125; &#125; 对比结构体需要自己造轮子，不能直接用 “==” C++ 可以重载 “==” 时间复杂度：好 = O(1) ；坏 = O(n)；平均 = O(n) 2. 单链表（链式存储） 优点：不要求大片连续空间，改容量方便 缺点：不可随机存取，耗费一定空间存放指针 单链表的定义 123456789101112typedef struct LNode&#123; //结点 ElemType data; //数据域 Struct LNode *next; //指针域&#125;LNode, *LinkList;/*typedef struct LNode LNode;typedef struct LNode *LinkList;*/struct LNode *p = (struct LNode *)malloc(sizeof(struct LNode));LNode *L; //强调这是结点LinkList L; //强调这是单链表 初始化不带头结点的单链表: 123456789typedef struct LNode&#123; //结点 ElemType data; //数据域 Struct LNode *next; //指针域&#125;LNode, *LinkList;bool InitList(LinkList &amp;L)&#123; L = NULL; //空表判断 return true;&#125; 1234void test()&#123; LinkList L; InitList(L);&#125; 初始化带头结点的单链表: 1234567bool InitList(LinkList &amp;L)&#123; L = (LNode *)malloc(sizeof(LNode)); if (L==NULL) return false; L-&gt;next = NULL; //空表判断 return true;&#125; 不带头结点，头指针指向的结点是实际存储数据的头结点；带头结点是指向一个不存放数据的节点；带头结点写代码更方便，对第一个结点的操作逻辑与其他结点不同。 单链表的基本操作 插入 带头结点 1234567891011121314151617181920bool ListInsert(LinkList &amp;L, int i, ElemType e)&#123; if(i &lt; 1)&#123; return false; &#125; LNode *p; int j = 0; p = L; while(p != NULL &amp;&amp; j &lt; i - 1)&#123; p = p -&gt; next; j++; &#125; if(p == NULL)&#123; return false; &#125; LNode *s = (LNode *)malloc(sizeof(LNode)); s -&gt; data = e; s -&gt; next = p-&gt; next; p -&gt; next = s; return true;&#125; 不带头结点：插入位序为1时需要更改头指针 L 的指向，使其指向新结点。 删除 带头结点 1234567891011121314151617181920bool ListDelete(LinkList &amp;L, int i)&#123; if(i &lt; 1)&#123; return false; &#125; LNode *p; LNode *p2; int j = 0; p = L; while(p != NULL &amp;&amp; j &lt; i - 1)&#123; p2 = p; p = p -&gt; next; j++; &#125; if(p == NULL)&#123; return false; &#125; p2 -&gt; next = p -&gt; next; free(p); return true;&#125; 不带头结点：删除第一个结点时需要更改头指针的指向，使其指向第二个结点。 查找(带头结点) 按位查找 123456789101112LNode * GetElem(LinkList L, int i)&#123; if(1 &lt; 0)&#123; return NULL; &#125; LNode *p = L; int j = 0; while(p != NULL &amp;&amp; j &lt; i)&#123; p = p -&gt; next; j++; &#125; return p;&#125; 头结点为第零个结点，若i = 0 则返回头结点。 按值查找 1234567LNode * LocateELem(LinkList L ,ElemType e)&#123; LNode *p = L -&gt; next; while(p != NULL &amp;&amp; p -&gt; data != e)&#123; p = p -&gt; next; &#125; return p;&#125; 显然，最坏时间复杂度为 O(n) 求表长 12345678int Lenth(LinkList L)&#123; LNode *p = L -&gt; next; int len = 0; while(p != NULL)&#123; len++; &#125; return len;&#125; 最坏时间复杂度为O(n) 单链表的建立（带头结点） 结点 1234typedef struct LNode&#123; ElemType data; struct LNode *next;&#125;LNode, *LinkList; 尾插法（正向建立） 设置一个表尾指针，每次在尾部插入元素相当于是对表尾指针所指向的元素进行后插操作。 123456789101112131415161718LinkList List_TailInsert(LinkList &amp;L)&#123; int x; //设 ElemType 为 int 类型 scanf(&quot;%d&quot;,&amp;x); //输入结点值 L = (LNode *)malloc(sizeof(LNode)); //分配内存 //L = NULL LNode *s = L; //临时指针 LNode *z = L; //尾指针 while(x != 114514)&#123; //114514 为“安全词” s = (LNode *)malloc(sizeof(LNode)); //分配内存 s -&gt; data = x; //赋值 r -&gt; next = s; //r 还指向上一个结点，此处令上一个结点的 next 指向 s r = s; //令 r 指向最后一个结点 scanf(&quot;%d&quot;,&amp;x); //再次扫描 &#125; r -&gt; next = NULL; //尾结点 next 置空 return L; &#125; 头插法（逆向建立） 对头指针进行后插操作 123456789101112131415LinkList List_HeadInsert(LinkList &amp;L)&#123; int x; L = (LNode *)malloc(sizeof(LNode)); L -&gt; next = NULL; LNode *s; scanf(&quot;%d&quot;, &amp;x); while(x != 1919810)&#123; s = (LNode *)malloc(sizeof(LNode)); s -&gt; data = x; s -&gt; next = L -&gt; next; L -&gt; next = s; scanf(&quot;%d&quot;, &amp;x); &#125; return L;&#125; 3. 双链表 结点定义 与单链表的区别是双链表多了一个 prior 指针，指向上一个结点，形成双向的链式结构。 12345typedef struct DNode&#123; //&quot;D&quot; 指 &quot;double&quot; ElemType data; struct DNode *prior; //指向前驱结点 struct DNode *next;&#125;DNode, * DLinkList; 双链表建立 与单链表相似，要注意的是头结点的 prior 指针永远指向NULL。 双链表的基本操作 插入： 与单链表相同，但要让新结点的prior指向其下一个结点的前驱结点，再令下一个前驱结点的 prior 指向新结点本身。 函数传入两个参数（DNode *p, DNode *s）；指在 p 结点后插入 s 结点。 注意判断边界条件及参数合法性（NULL） 删除后继结点： 判断参数合法性，参数传入（DNode *p）；指删除 p 结点后的结点。 判断 p 是否有后继节点 判断 p 的后继节点是否有后继节点，以决定是否修改其prior指针。 free 销毁双链表 持续对头结点的 next 进行 删除后继结点 操作，直到其 next 为 NULL。 删除 头结点 L 。 遍历 1234567891011//后向遍历while(p != NULL)&#123; //func p = p -&gt; next;&#125;//前向遍历while(p != NULL)&#123; //func p = p -&gt; prior;&#125; 只处理数据节点可直接跳过头结点，判断条件改为（ p -&gt; next != NULL） 循环链表 分为循环单链表和循环双链表 再一次套娃，首尾相连。 静态链表 静态链表定义 分配一片连续的存储空间，结点集中存储，其游标充当指针的作用。 12345#define MaxSize 10typedef struct &#123; ElemType data; int next; //仅需存储下一个元素的数组下标&#125;SLinkList[MaxSize]; 其它 尾结点的指针值为 -1 找到某一位序结点的时间复杂度为O(n) 初始化应抹除脏数据 与OS 的文件分配表( FAT )关联 顺序表与链表的比较 顺序表 链表 容量弹性 就这？ NB 增、删 就这？ NB 查 NB 就这？ 开放式问题答题思路： Q：请描述顺序表和链表的#@%，实现线性表时，用顺序表还是链表好？ A： 逻辑结构都是线性结构 存储结构不同 +（各自特点、优缺点） 基本操作效率不同（初始化、增删改查） 结论","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lapplandsp.github.io/LapplandSP/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"【数据结构·零】 算法","slug":"【数据结构·零】 算法","date":"2022-06-14T15:21:42.000Z","updated":"2022-06-18T07:46:35.946Z","comments":true,"path":"2022/06/14/【数据结构·零】 算法/","link":"","permalink":"https://lapplandsp.github.io/LapplandSP/2022/06/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E9%9B%B6%E3%80%91%20%E7%AE%97%E6%B3%95/","excerpt":"","text":"第一章 算法 1. 基本概念 程序 = 数据结构 + 算法 数据结构是要处理的信息 算法是处理信息的步骤 算法的五个特性 有穷性：一个算法必须在有穷步之后结束，且每一步的时间都是有穷的。 算法必须是有穷的，而程序可以是无穷的。 确定性： 算法中每条指令都必须有确切的含义，相同的输入对应得出相同的输出。 可行性： 算法中描述的操作都可以通过已经实现的基本运算执行有限次实现。 输入 输出 “好”算法的特点 正确性：能正确解决问题 可读性 健壮性：能处理异常情况 高效率与低存储量需求： 省时（低时间复杂度） 省内存（低空间复杂度） 2. 时间复杂度 计算 找到一个基本操作（最深层循环） 分析该基本操作的执行次数与问题规模n的关系 x = f(n) x 的数量级 O(x) 就是算法时间复杂度 T(n) 常用技巧 加法规则：O( f(n) ) + O( g(n) ) = O( max( f(n), g(n) ) ) 乘法规则：O(f(n)) * O(g(n)) = O( f(n) * g(n) ) O(1) &lt; O(log2n) &lt; O(n) &lt; O(n2) &lt; O(n3) &lt; O(2n) &lt; O(n!) &lt; O(nn) 常对幂指阶 顺序执行的代码只会影响常数项，可以忽略。 只需挑循环中的一个基本操作，分析他的执行次数与n的关系。 如果有多层嵌套循环，只需关注最深层循环循环了几次。 三种时间复杂度 最坏时间复杂度：考虑输入数据“最坏”的情况 平均时间复杂度：考虑所有输入数据都等概率出现的情况 最好时间复杂度：考虑输入数据“最好”的情况 3. 空间复杂度 计算 普通程序 找到所占空间大小与问题规模相关的变量 分析所占空间 x 与问题规模 n 的关系 x = f(n) x 的数量级 O(x) 就是算法空间复杂度 S(n) 递归程序 找到递归调用的深度 x 与问题规模 n 的关系 x = f(n) x 的数量级 O(x) 就是算法空间复杂度 S(n) 有的算法各层函数所需存储空间不同，分析方法略有区别 大部分递归调用都是 空间复杂度 = 递归调用的深度 常用技巧 加法规则、乘法规则、常对幂指阶 S(n) = O(1) 的常数阶算法可以原地工作","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lapplandsp.github.io/LapplandSP/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}],"categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lapplandsp.github.io/LapplandSP/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Markdown","slug":"Markdown","permalink":"https://lapplandsp.github.io/LapplandSP/tags/Markdown/"}]}