{"meta":{"title":"Lappland","subtitle":"","description":"LapplandSP","author":"LapplandSP","url":"https://lapplandsp.github.io/LapplandSP","root":"/LapplandSP/"},"pages":[{"title":"友情链接","date":"2022-06-13T14:21:01.871Z","updated":"2022-06-13T14:21:01.871Z","comments":true,"path":"links/index.html","permalink":"https://lapplandsp.github.io/LapplandSP/links/index.html","excerpt":"","text":""}],"posts":[{"title":"数据结构-贰：表","slug":"数据结构-贰：表","date":"2022-06-14T15:22:26.000Z","updated":"2022-06-14T15:23:25.319Z","comments":true,"path":"2022/06/14/数据结构-贰：表/","link":"","permalink":"https://lapplandsp.github.io/LapplandSP/2022/06/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B4%B0%EF%BC%9A%E8%A1%A8/","excerpt":"","text":"第二章 线性表 线性表定义（逻辑结构） 线性表是具有相同数据类型的n (n&gt;=0) 个数据元素的有限序列，其中 n 为表长，当n = 0时，线性表是一个空表。 其一般表示为： L = (a1 , a2, … , ai , ai+1 , an ) 几个概念： ai是线性标中的“第i个” 元素线性标中的位序（从1开始） a1是表头元素；an是表尾元素 除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继 线性表基本操作（运算） 创建、销毁、增删改查（所有数据结构适用的记忆思路） 判空、判长、打印输出等 其它 传参何时引用“&amp;” 函数名易读 线性表存储（物理结构） 1. 顺序表（顺序存储） 优点：可随机存取，存储密度高 缺点：要求大片连续空间，改变容量不方便 顺序表定义 用顺序存储的方式实现线性表顺序存储。将逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素间的关系由存储单元的邻接关系来体现。 顺序表实现 静态分配 “静态数组” 大小一旦确定便无法更改 动态分配 1234567#include &lt;stdlib.h&gt;#define InitSize 10typedef struct&#123; int *data; int MaxSize; int length;&#125; SeqList; 12345void InitList(SeqList &amp;L)&#123; L.data = (ElemType *)malloc(sizeof(ElemType) * InitSize); L.length = 0; L.MaxSize = InitSize;&#125; 123456789void IncreaseSize(SeqList &amp;L, int len)&#123; int *p = L.data; L.data = (int *)malloc((L.MaxSize + len) * sizeof(int)); for(int i = 0; i &lt; L.length; i++)&#123; L.data[i] = p[i]; //时间开销较大 &#125; L.MaxSize = L.MaxSize + len; free(p);&#125; 123456int main()&#123; SeqList L; InitList(L); IncreaseSize(L, 5); return 0;&#125; 顺序表的特点 随机访问，可以在 O(1) 时间内找到第 i 个元素。 存储密度高，每个节点只存储数据元素。 扩展容量不方便。（动态方式时间复杂度较高） 插入、删除操作不方便，需移动大量元素。 顺序表的基本操作 插入 ListInsert(&amp;L , i , e) 将插入位置之后的元素统一后移一格 平均时间复杂度 = O(n) ；最好 = O(1) ；最坏 = O(N) 1234567891011121314151617#define MaxSize 10typedef struct&#123; int data[MaxSize];//静态数组 int length;&#125;SeqList;bool ListInsert(SeqList &amp;L, int i, int e)&#123; if(i &lt;= 1 || i &gt; L.Lenth + 1) return false; if(L.length &gt;= MaxSize) return false; for(int j = L.length; j &gt;= i;j--) L.data[j] = L.data[j-1]; L.data[i-1] = e; L.length++; return true;&#125; 删除 ListDelete(&amp;L , i , &amp;e) 将删除位置之后的元素统一前移一格 平均时间复杂度 = O(n) ；最好 = O(1) ；最坏 = O(N) 123456789bool ListDelete(SqList &amp;L, int i, int &amp;e)&#123; if(i &lt; 1 || i &gt; L.lenth) return false; e = L.data[i - 1]; for (int j = 1; j &lt; L.lenth;j++) L.data[j-1] = L.data[j]; L.lenth--; return true;&#125; 12345678910int main()&#123; SqList L; InitList(L); int e = -1; if(ListDelete(L, 3, e)) printf(&quot;No.3 deleted, value = %d\\n&quot;, e); else printf(&quot;i is sb.&quot;); return 0;&#125; 代码要点 注意次序 i 和数组下标的关系 判断 i 的合法性 移动元素顺序 “&amp;”的使用 顺序表的查找 按位查找 时间复杂度 = O(1) ，随机存取。 访问时，按照指针的数据类型大小计算跳跃距离。1234567891011122. **按值查找** ```c int LocalElem(SeqList L,ElemType e)&#123; for(int i = 0; i &lt; L.lenth ; i++)&#123; if(L.data[i] == e)&#123; return i+1; &#125; return 0; &#125; &#125; 对比结构体需要自己造轮子，不能直接用 “==” C++ 可以重载 “==” 时间复杂度：好 = O(1) ；坏 = O(n)；平均 = O(n) 2. 单链表（链式存储） 优点：不要求大片连续空间，改容量方便 缺点：不可随机存取，耗费一定空间存放指针 单链表定义 123456789101112typedef struct LNode&#123; //结点 ElemType data; //数据域 Struct LNode *next; //指针域&#125;LNode, *LinkList;/*typedef struct LNode LNode;typedef struct LNode *LinkList;*/struct LNode *p = (struct LNode *)malloc(sizeof(struct LNode));LNode *L; //强调这是结点LinkList L; //强调这是单链表 初始化不带头结点的单链表: 123456789typedef struct LNode&#123; //结点 ElemType data; //数据域 Struct LNode *next; //指针域&#125;LNode, *LinkList;bool InitList(LinkList &amp;L)&#123; L = NULL; //空表判断 return true;&#125; 1234void test()&#123; LinkList L; InitList(L);&#125; 初始化带头结点的单链表: 1234567bool InitList(LinkList &amp;L)&#123; L = (LNode *)malloc(sizeof(LNode)); if (L==NULL) return false; L-&gt;next = NULL; //空表判断 return true;&#125; 不带头结点，头指针指向的结点是实际存储数据的头结点；带头结点是指向一个不存放数据的节点；带头结点写代码更方便，对第一个结点的操作逻辑与其他结点不同。 单链表插入与删除 1. 插入 带头结点 1234567891011121314151617181920bool ListInsert(LinkList &amp;L, int i, ElemType e)&#123; if(i &lt; 1)&#123; return false; &#125; LNode *p; int j = 0; p = L; while(p != NULL &amp;&amp; j &lt; i - 1)&#123; p = p -&gt; next; j++; &#125; if(p == NULL)&#123; return false; &#125; LNode *s = (LNode *)malloc(sizeof(LNode)); s -&gt; data = e; s -&gt; next = p-&gt; next; p -&gt; next = s; return true;&#125; 2. 删除 带头结点 1234567891011121314151617181920bool ListDelete(LinkList &amp;L, int i)&#123; if(i &lt; 1)&#123; return false; &#125; LNode *p; LNode *p2; int j = 0; p = L; while(p != NULL &amp;&amp; j &lt; i - 1)&#123; p2 = p; p = p -&gt; next; j++; &#125; if(p == NULL)&#123; return false; &#125; p2 -&gt; next = p -&gt; next; free(p); return true;&#125; 单链表查找 按位查找 按值查找","categories":[],"tags":[]},{"title":"数据结构-壹：算法","slug":"数据结构-壹：算法","date":"2022-06-14T15:21:42.000Z","updated":"2022-06-14T15:23:06.161Z","comments":true,"path":"2022/06/14/数据结构-壹：算法/","link":"","permalink":"https://lapplandsp.github.io/LapplandSP/2022/06/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A3%B9%EF%BC%9A%E7%AE%97%E6%B3%95/","excerpt":"","text":"第一章 算法 1. 基本概念 程序 = 数据结构 + 算法 数据结构是要处理的信息 算法是处理信息的步骤 算法的五个特性 有穷性：一个算法必须在有穷步之后结束，且每一步的时间都是有穷的。 算法必须是有穷的，而程序可以是无穷的。 确定性： 算法中每条指令都必须有确切的含义，相同的输入对应得出相同的输出。 可行性： 算法中描述的操作都可以通过已经实现的基本运算执行有限次实现。 输入 输出 “好”算法的特点 正确性：能正确解决问题 可读性 健壮性：能处理异常情况 高效率与低存储量需求： 省时（低时间复杂度） 省内存（低空间复杂度） 2. 时间复杂度 计算 找到一个基本操作（最深层循环） 分析该基本操作的执行次数与问题规模n的关系 x = f(n) x 的数量级 O(x) 就是算法时间复杂度 T(n) 常用技巧 加法规则：O( f(n) ) + O( g(n) ) = O( max( f(n), g(n) ) ) 乘法规则：O(f(n)) * O(g(n)) = O( f(n) * g(n) ) O(1) &lt; O(log2n) &lt; O(n) &lt; O(n2) &lt; O(n3) &lt; O(2n) &lt; O(n!) &lt; O(nn) 常对幂指阶 顺序执行的代码只会影响常数项，可以忽略。 只需挑循环中的一个基本操作，分析他的执行次数与n的关系。 如果有多层嵌套循环，只需关注最深层循环循环了几次。 三种时间复杂度 最坏时间复杂度：考虑输入数据“最坏”的情况 平均时间复杂度：考虑所有输入数据都等概率出现的情况 最好时间复杂度：考虑输入数据“最好”的情况 3. 空间复杂度 计算 普通程序 找到所占空间大小与问题规模相关的变量 分析所占空间 x 与问题规模 n 的关系 x = f(n) x 的数量级 O(x) 就是算法空间复杂度 S(n) 递归程序 找到递归调用的深度 x 与问题规模 n 的关系 x = f(n) x 的数量级 O(x) 就是算法空间复杂度 S(n) 有的算法各层函数所需存储空间不同，分析方法略有区别 大部分递归调用都是 空间复杂度 = 递归调用的深度 常用技巧 加法规则、乘法规则、常对幂指阶 S(n) = O(1) 的常数阶算法可以原地工作","categories":[],"tags":[]}],"categories":[],"tags":[]}