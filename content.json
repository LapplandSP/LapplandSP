{"meta":{"title":"Lappland","subtitle":"","description":"LapplandSP","author":"LapplandSP","url":"https://lapplandsp.github.io/LapplandSP","root":"/LapplandSP/"},"pages":[{"title":"友情链接","date":"2022-06-13T14:21:01.871Z","updated":"2022-06-13T14:21:01.871Z","comments":true,"path":"links/index.html","permalink":"https://lapplandsp.github.io/LapplandSP/links/index.html","excerpt":"","text":""}],"posts":[{"title":"【数据结构·A】栈与队列的应用","slug":"【数据结构·A】栈与队列的应用","date":"2022-06-18T09:46:31.000Z","updated":"2022-06-18T09:47:06.179Z","comments":true,"path":"2022/06/18/【数据结构·A】栈与队列的应用/","link":"","permalink":"https://lapplandsp.github.io/LapplandSP/2022/06/18/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7A%E3%80%91%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"栈与队列的应用 1. 括号匹配（栈） 遇到左括号就入栈，遇到右括号就弹出（大、中、小括号应匹配） 只有左括号，没有右括号，报错。 有右括号，但栈空，报错。 弹出的左括号与右括号不匹配，报错。 12345#define MaxSize 20typedef struct&#123; char data[MaxSize]; int top;&#125; SqStack; 1234567891011121314151617181920212223bool BracketCheck(char str[], int lenth)&#123; SqStack S; InitStack(S); for(int i = 0; i &lt; lenth; i++ )&#123; if(str[i] == &quot;(&quot; || str[i] == &quot;[&quot; || str[i] == &quot;&#123;&quot;)&#123; return false; &#125;else&#123; if(StackEmpty(S)) return false; char topChar; pop(S, topChar); if(str[i] == &quot;(&quot; &amp;&amp; topChar != &quot;)&quot;) return false; if(str[i] == &quot;[&quot; &amp;&amp; topChar != &quot;]&quot;) return false; if(str[i] == &quot;&#123;&quot; &amp;&amp; topChar != &quot;&#125;&quot;) return false; &#125; &#125; return StackEmpty(S);&#125; 可以直接使用基本操作，但要注释说明接口 1234567891011//初始化栈void InitStack(SqStack &amp;S) //判断空栈bool StackEmpty(SqStack S) //压栈bool Push(SqStack &amp;S, char x)//出栈bool Pop(SqStack &amp;S, char &amp;x) 2. 表达式求值（栈） 中缀表达式 前缀表达式 （波兰表达式） 后缀表达式 （逆波兰表达式） 名词 操作数：数字 / 变量 界限符：括号 运算符：加减乘除 语法 中缀表达式 后缀表达式 前缀表达式 a + b a b + + a b a + b - c a b + c - - + a b c a + b - c * d a b + c d * - - + a b * c d 原则 左优先原则：只要有靠近左边的运算符可以运算， 就优先生效左边的运算符。 可保证运算顺序唯一。 中缀表达式转后缀表达式 初始化栈，保存暂时不能确定运算顺序的运算符。 遇到操作数，直接加入后缀表达式。 遇到界限符，遇到左括号 “(” 直接入栈，遇到右括号 “)” 依次弹出栈内运算符并加入后缀表达式，直到弹出左括号 “(” 为止，左括号不入栈。 遇到运算符，依次弹出栈中优先级高于或等于该运算符的所有运算符，加入后缀表达式，直到栈空或遇到左括号为止，再将此运算符入栈。 以上述方法处理完所有字符后，将剩余运算符依次弹出，加入后缀表达式。 后缀表达式计算 从左往右扫描下一个元素，直到处理完所有元素。 扫描到操作数则入栈。 扫描到运算符则弹出位于栈顶的两个操作数，运算结果压回栈顶。 中缀表达式计算 初始化两个栈，一个存操作数，一个存运算符。 扫描到操作数，压入栈。 扫描到运算符，依次弹出栈中优先级高于或等于该运算符的所有运算符，加入后缀表达式，直到栈空或遇到左括号为止，再将此运算符入栈。每弹出一个运算符都需要弹出两个操作数执行计算，并将结果压回栈中。 3. 递归（栈） 递归算法效率很低。 在递归调用的过程中，系统为每一层的返回点、局部变量、传入实参等等都开辟了递归工作栈来进行数据存储。 递归次数多容易造成栈溢出。 递归算法可能包含多次重复运算。 可以将递归算法转换为非递归算法，通常需要借助栈来实现。 4. 树的层次遍历（队列） 将根结点入队。 处理队头元素，若有子节点则全部入队，最后该结点出队。 以此可以完成树的层次遍历。 5. 图的广度优先遍历（队列） 创建队列 从第一个结点开始遍历，将与其相邻的所有未遍历过的结点全部入队。 处理队头元素，将与其相邻的所有未遍历过的结点全部入队。 以此完成图的广度优先遍历。 6. 操作系统 先来先服务 First come first service (FCFS)","categories":[],"tags":[{"name":"数据结构 算法","slug":"数据结构-算法","permalink":"https://lapplandsp.github.io/LapplandSP/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"}]},{"title":"【数据结构·二】栈、队列和数组","slug":"【数据结构·二】栈、队列和数组","date":"2022-06-18T07:45:40.000Z","updated":"2022-06-18T07:46:17.997Z","comments":true,"path":"2022/06/18/【数据结构·二】栈、队列和数组/","link":"","permalink":"https://lapplandsp.github.io/LapplandSP/2022/06/18/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E4%BA%8C%E3%80%91%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84/","excerpt":"","text":"第三章 栈、队列和数组 栈 栈的定义 栈（stack）是一种仅允许在一端（栈顶）进行插入或删除操作的线性表。 名词 栈顶：允许插入和删除的一端 栈底：不允许插入和删除的一端 空栈：栈中没有元素 特点 先进后出：Last in first out (LIFO) 栈的基本操作 创建与销毁 创建：InitStack(&amp;S) 销毁：DestroyStack(&amp;S) 增、删 增（压栈）：push(&amp;S, x) 删（出栈）：pop(&amp;S, &amp;x) 出栈时会返回栈顶结点值 查 读栈顶：GetTop(S, &amp;x) 判空：StackEmpty(S) 判断栈S是否为空，返回布尔值 顺序栈的实现（顺序存储） 顺序栈的定义 1234typedef struct&#123; ElemType data[MaxSize]; int top; //栈顶指针（数组下标）&#125;SqStack; 顺序栈基本操作 12345678910111213141516171819202122232425262728293031void InitStack(SqStack &amp;S)&#123; S.top = -1; //可初始化为0，此时push与pop操作将直接对top所指向位置进行操作。 /*可以抹除脏数据*/&#125;bool push(SqStack &amp;S, ElemType x)&#123; if(S.top == MaxSize -1)&#123; return false; &#125; S.top = S.top +1; S.data[top] = x; return true;&#125;bool pop(SqStack &amp;S, ElemType &amp;x)&#123; if(S.top == -1)&#123; return false; &#125; x = S.data[S.top]; S.data[S.top] = 0; S.top = S.top -1; return true;&#125;bool GetTop(SqStack &amp;S, ElemType &amp;x)&#123; if(S.top == -1)&#123; return false; &#125; x = S.data[S.top]; return true;&#125; 共享栈（顺序存储） 共享栈可以存储两串数据，分别从栈的两端向内相向存储，栈顶在内侧，top指针相同时两个栈均为满栈。 链栈的实现（链式存储） 链栈定义 1234typedef struct LinkNode&#123; ElemType data; struct LinkNode *next;&#125;LiStackNode, *LiStack; 链栈基本操作 链栈的基本操作与单链表几乎相同，区别在于链栈仅允许在栈顶进行插入与删除。 推荐使用不带头结点方式，栈顶指针来指向栈顶元素。 12345678910111213141516171819LiStack InitStack()&#123; LiStackNode* top = (LiStackNode*)malloc(sizeof(ListackNode)); if(top == NULL) return flase; top -&gt; next = NULL; return true;&#125;bool push(LiStack top, ElemType x)&#123; LiStackNode *p = (LiStackNode *)malloc(sizeof(LiStackNode)); if(p == NULL) return false; p -&gt; data = x; p -&gt; next = top -&gt; next; top -&gt; next = p; return true&#125;//etc. 队列 队列的定义 队列（queue）是只允许在队列的一端进行插入（入队），另一端进行删除（出队）的线性表。 名词 队头：删除的一端为队头 队尾：插入的一段为队尾 空队列：对头 == 队尾 特点 先进先出：First in first out (FIFO) 队列的基本操作 创建与销毁 创建：InitQueue(&amp;Q) 销毁：DestroyQueue(&amp;Q) 增、删 增（入队）：Enqueue(&amp;Q, x) 删（出队）：Dequeue(&amp;Q, &amp;x) 出队时会返回队头结点值 查 读队列顶：GetTop(Q, &amp;x) 判空：QueueEmpty(Q) 判断栈S是否为空，返回布尔值 队列的实现（顺序存储） 顺序队列的定义 需要有两个指针指向队头队尾 12345#define MaxSize 20typedef struct&#123; ElemType data[MaxSize]; int front, rear;&#125;SqQueue; //sequence 顺序队列的基本操作 初始化 123void InitQueue(SqQueue &amp;Q)&#123; Q.rear = Q.front = 0;&#125; 判空：队头指针 == 队尾指针 入队：元素插入队尾 队尾指针后移 123456789![image-20220618150319668](https://blog-lappland.oss-cn-hangzhou.aliyuncs.com/img/image-20220618150319668.png)**循环队列中应牺牲一个存储单元，使得rear != front ，以免影响判空。- 出队 ```c Q.front= (Q.front + 1) % MaxSize 取队头元素 直接读取队头指针处的值。 扩展 可以在顺序队列中定义变量 size ，存储队列长度，并以此为判空依据。 可以在顺序队列中定义变量 tag ，每次删除成功都令其为0，每次插入成功令其为1，以 tag 值为判空依据。 队列的实现（链式存储） 链式队列为单链表的阉割版 链式队列定义 1234567typedef struct LinkNode&#123; ElemType data; struct LinkNode * next;&#125;LinkNode;typedef struct LinkQueue&#123; LinkNode *front, *rear;&#125;LinkQueue; 链式队列基本操作 初始化 带头结点：front 与 rear 同时指向头结点，front 的 next （即头结点的next）指向NULL 不带头结点：直接全指向NULL 入队 新结点的 next 一定是 NULL 队尾结点 next 先指向新结点，新结点 next 指向NULL 不带头结点需要判断是否为第一个元素 出队 判空 判断是否为最后一个结点出队，若是则将rear = front（不带头结点直接全部指向NULL） free 扩展 可以加入 lenth 变量记录其长度。 链式队列除非内存空间已满，否则不会满。 双端队列 允许两端的插入和删除。 输入受限的双端队列 输出受限的双端队列 双端队列考点 输出顺序是否合法","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lapplandsp.github.io/LapplandSP/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"使用Typora绘制图表","slug":"使用Typora绘制图表","date":"2022-06-17T18:47:50.000Z","updated":"2022-06-17T18:50:35.509Z","comments":true,"path":"2022/06/18/使用Typora绘制图表/","link":"","permalink":"https://lapplandsp.github.io/LapplandSP/2022/06/18/%E4%BD%BF%E7%94%A8Typora%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8/","excerpt":"","text":"使用 Typora 绘制图表 序列图 12345```sequenceAlice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks!``` 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 流程图 12345678910```flowst=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op``` 12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op Mermaid 序列图 1234567891011&lt;pre class=&quot;mermaid&quot;&gt; %% 这里是注释可以随便写 sequenceDiagram Alice-&gt;&gt;Bob: Hello Bob, how are you? alt is sick Bob-&gt;&gt;Alice: Not so good :( else is well Bob-&gt;&gt;Alice: Feeling fresh like a daisy end opt Extra response Bob-&gt;&gt;Alice: Thanks for asking end&lt;/pre&gt; %% 这里是注释可以随便写 sequenceDiagram Alice->>Bob: Hello Bob, how are you? alt is sick Bob->>Alice: Not so good :( else is well Bob->>Alice: Feeling fresh like a daisy end opt Extra response Bob->>Alice: Thanks for asking end 流程图 12345&lt;pre class=&quot;mermaid&quot;&gt; graph LRA[Hard edge] --&gt;B(Round edge) B --&gt; C&#123;Decision&#125; C --&gt;|One| D[Result one] C --&gt;|Two| E[Result two]&lt;/pre&gt; graph LR A[Hard edge] -->B(Round edge) B --> C{Decision} C -->|One| D[Result one] C -->|Two| E[Result two] “LR” 表示该流程图是从左（L）到右（R）的顺序生成 从上到下参数为 “TB” 树图 1234567891011121314151617181920&lt;pre class=&quot;mermaid&quot;&gt; graph TBA((A))B((B))C((C))D((D))E((E))F((F))G((G))H((H))I((I))J((J)) K((K))A--&gt;BA--&gt;CA--&gt;DE--&gt;FG--&gt;HG--&gt;II--&gt;J&lt;/pre&gt; graph TB A((A)) B((B)) C((C)) D((D)) E((E)) F((F)) G((G)) H((H)) I((I)) J((J)) K((K)) A-->B A-->C A-->D E-->F G-->H G-->I I-->J 其中，A((B))代表一个结点，A类似于key，而B类似于value。 甘特图 12345678910111213141516171819202122232425262728&lt;pre class=&quot;mermaid&quot;&gt; %% Example with selection of syntaxes gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page : 20h Add another diagram to demo page : 48h&lt;/pre&gt; %% Example with selection of syntaxes gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page : 20h Add another diagram to demo page : 48h 类图 123456789101112131415161718192021&lt;pre class=&quot;mermaid&quot;&gt; classDiagram Animal &lt;|-- Duck Animal &lt;|-- Fish Animal &lt;|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck&#123; +String beakColor +swim() +quack() &#125; class Fish&#123; -int sizeInFeet -canEat() &#125; class Zebra&#123; +bool is_wild +run() &#125;&lt;/pre&gt; classDiagram Animal Moving Moving --> Still Moving --> Crash Crash --> [*] 饼图 12345&lt;pre class=&quot;mermaid&quot;&gt; pie title Pie Chart &quot;Dogs&quot; : 386 &quot;Cats&quot; : 85 &quot;Rats&quot; : 150&lt;/pre&gt; pie title Pie Chart \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 150 Typora 官方帮助文档 内容来源于Typora 文档以及Mermaid 文档。 详细内容请查阅官方文档。","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://lapplandsp.github.io/LapplandSP/tags/Markdown/"}]},{"title":"【数据结构·一】 线性表","slug":"【数据结构·一】 线性表","date":"2022-06-14T15:22:26.000Z","updated":"2022-06-18T07:47:31.089Z","comments":true,"path":"2022/06/14/【数据结构·一】 线性表/","link":"","permalink":"https://lapplandsp.github.io/LapplandSP/2022/06/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E4%B8%80%E3%80%91%20%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"","text":"第二章 线性表 线性表定义（逻辑结构） 线性表是具有相同数据类型的n (n&gt;=0) 个数据元素的有限序列，其中 n 为表长，当n = 0时，线性表是一个空表。 其一般表示为： L = (a1 , a2, … , ai , ai+1 , an ) 几个概念： ai是线性标中的“第i个” 元素线性标中的位序（从1开始） a1是表头元素；an是表尾元素 除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继 线性表基本操作（运算） 创建、销毁、增删改查（所有数据结构适用的记忆思路） 判空、判长、打印输出等 其它: 传参何时引用“&amp;” 函数名易读 线性表的物理结构 1. 顺序表（顺序存储） 优点：可随机存取，存储密度高 缺点：要求大片连续空间，改变容量不方便 顺序表的定义 用顺序存储的方式实现线性表顺序存储。将逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素间的关系由存储单元的邻接关系来体现。 顺序表的实现 静态分配 “静态数组” 大小一旦确定便无法更改 动态分配 1234567#include &lt;stdlib.h&gt;#define InitSize 10typedef struct&#123; int *data; int MaxSize; int length;&#125; SeqList; 12345void InitList(SeqList &amp;L)&#123; L.data = (ElemType *)malloc(sizeof(ElemType) * InitSize); L.length = 0; L.MaxSize = InitSize;&#125; 123456789void IncreaseSize(SeqList &amp;L, int len)&#123; int *p = L.data; L.data = (int *)malloc((L.MaxSize + len) * sizeof(int)); for(int i = 0; i &lt; L.length; i++)&#123; L.data[i] = p[i]; //时间开销较大 &#125; L.MaxSize = L.MaxSize + len; free(p);&#125; 123456int main()&#123; SeqList L; InitList(L); IncreaseSize(L, 5); return 0;&#125; 顺序表的特点 随机访问，可以在 O(1) 时间内找到第 i 个元素。 存储密度高，每个节点只存储数据元素。 扩展容量不方便。（动态方式时间复杂度较高） 插入、删除操作不方便，需移动大量元素。 顺序表的基本操作 插入 ListInsert(&amp;L , i , e) 将插入位置之后的元素统一后移一格 平均时间复杂度 = O(n) ；最好 = O(1) ；最坏 = O(N) 1234567891011121314151617#define MaxSize 10typedef struct&#123; int data[MaxSize];//静态数组 int length;&#125;SeqList;bool ListInsert(SeqList &amp;L, int i, int e)&#123; if(i &lt;= 1 || i &gt; L.Lenth + 1) return false; if(L.length &gt;= MaxSize) return false; for(int j = L.length; j &gt;= i;j--) L.data[j] = L.data[j-1]; L.data[i-1] = e; L.length++; return true;&#125; 删除 ListDelete(&amp;L , i , &amp;e) 将删除位置之后的元素统一前移一格 平均时间复杂度 = O(n) ；最好 = O(1) ；最坏 = O(N) 123456789bool ListDelete(SqList &amp;L, int i, int &amp;e)&#123; if(i &lt; 1 || i &gt; L.lenth) return false; e = L.data[i - 1]; for (int j = 1; j &lt; L.lenth;j++) L.data[j-1] = L.data[j]; L.lenth--; return true;&#125; 12345678910int main()&#123; SqList L; InitList(L); int e = -1; if(ListDelete(L, 3, e)) printf(&quot;No.3 deleted, value = %d\\n&quot;, e); else printf(&quot;i is sb.&quot;); return 0;&#125; 代码要点 注意次序 i 和数组下标的关系 判断 i 的合法性 移动元素顺序 “&amp;”的使用 查找 按位查找 时间复杂度 = O(1) ，随机存取。 访问时，按照指针的数据类型大小计算跳跃距离。1234567891011122. 按值查找 ```c int LocalElem(SeqList L,ElemType e)&#123; for(int i = 0; i &lt; L.lenth ; i++)&#123; if(L.data[i] == e)&#123; return i+1; &#125; return 0; &#125; &#125; 对比结构体需要自己造轮子，不能直接用 “==” C++ 可以重载 “==” 时间复杂度：好 = O(1) ；坏 = O(n)；平均 = O(n) 2. 单链表（链式存储） 优点：不要求大片连续空间，改容量方便 缺点：不可随机存取，耗费一定空间存放指针 单链表的定义 123456789101112typedef struct LNode&#123; //结点 ElemType data; //数据域 Struct LNode *next; //指针域&#125;LNode, *LinkList;/*typedef struct LNode LNode;typedef struct LNode *LinkList;*/struct LNode *p = (struct LNode *)malloc(sizeof(struct LNode));LNode *L; //强调这是结点LinkList L; //强调这是单链表 初始化不带头结点的单链表: 123456789typedef struct LNode&#123; //结点 ElemType data; //数据域 Struct LNode *next; //指针域&#125;LNode, *LinkList;bool InitList(LinkList &amp;L)&#123; L = NULL; //空表判断 return true;&#125; 1234void test()&#123; LinkList L; InitList(L);&#125; 初始化带头结点的单链表: 1234567bool InitList(LinkList &amp;L)&#123; L = (LNode *)malloc(sizeof(LNode)); if (L==NULL) return false; L-&gt;next = NULL; //空表判断 return true;&#125; 不带头结点，头指针指向的结点是实际存储数据的头结点；带头结点是指向一个不存放数据的节点；带头结点写代码更方便，对第一个结点的操作逻辑与其他结点不同。 单链表的基本操作 插入 带头结点 1234567891011121314151617181920bool ListInsert(LinkList &amp;L, int i, ElemType e)&#123; if(i &lt; 1)&#123; return false; &#125; LNode *p; int j = 0; p = L; while(p != NULL &amp;&amp; j &lt; i - 1)&#123; p = p -&gt; next; j++; &#125; if(p == NULL)&#123; return false; &#125; LNode *s = (LNode *)malloc(sizeof(LNode)); s -&gt; data = e; s -&gt; next = p-&gt; next; p -&gt; next = s; return true;&#125; 不带头结点：插入位序为1时需要更改头指针 L 的指向，使其指向新结点。 删除 带头结点 1234567891011121314151617181920bool ListDelete(LinkList &amp;L, int i)&#123; if(i &lt; 1)&#123; return false; &#125; LNode *p; LNode *p2; int j = 0; p = L; while(p != NULL &amp;&amp; j &lt; i - 1)&#123; p2 = p; p = p -&gt; next; j++; &#125; if(p == NULL)&#123; return false; &#125; p2 -&gt; next = p -&gt; next; free(p); return true;&#125; 不带头结点：删除第一个结点时需要更改头指针的指向，使其指向第二个结点。 查找(带头结点) 按位查找 123456789101112LNode * GetElem(LinkList L, int i)&#123; if(1 &lt; 0)&#123; return NULL; &#125; LNode *p = L; int j = 0; while(p != NULL &amp;&amp; j &lt; i)&#123; p = p -&gt; next; j++; &#125; return p;&#125; 头结点为第零个结点，若i = 0 则返回头结点。 按值查找 1234567LNode * LocateELem(LinkList L ,ElemType e)&#123; LNode *p = L -&gt; next; while(p != NULL &amp;&amp; p -&gt; data != e)&#123; p = p -&gt; next; &#125; return p;&#125; 显然，最坏时间复杂度为 O(n) 求表长 12345678int Lenth(LinkList L)&#123; LNode *p = L -&gt; next; int len = 0; while(p != NULL)&#123; len++; &#125; return len;&#125; 最坏时间复杂度为O(n) 单链表的建立（带头结点） 结点 1234typedef struct LNode&#123; ElemType data; struct LNode *next;&#125;LNode, *LinkList; 尾插法（正向建立） 设置一个表尾指针，每次在尾部插入元素相当于是对表尾指针所指向的元素进行后插操作。 123456789101112131415161718LinkList List_TailInsert(LinkList &amp;L)&#123; int x; //设 ElemType 为 int 类型 scanf(&quot;%d&quot;,&amp;x); //输入结点值 L = (LNode *)malloc(sizeof(LNode)); //分配内存 //L = NULL LNode *s = L; //临时指针 LNode *z = L; //尾指针 while(x != 114514)&#123; //114514 为“安全词” s = (LNode *)malloc(sizeof(LNode)); //分配内存 s -&gt; data = x; //赋值 r -&gt; next = s; //r 还指向上一个结点，此处令上一个结点的 next 指向 s r = s; //令 r 指向最后一个结点 scanf(&quot;%d&quot;,&amp;x); //再次扫描 &#125; r -&gt; next = NULL; //尾结点 next 置空 return L; &#125; 头插法（逆向建立） 对头指针进行后插操作 123456789101112131415LinkList List_HeadInsert(LinkList &amp;L)&#123; int x; L = (LNode *)malloc(sizeof(LNode)); L -&gt; next = NULL; LNode *s; scanf(&quot;%d&quot;, &amp;x); while(x != 1919810)&#123; s = (LNode *)malloc(sizeof(LNode)); s -&gt; data = x; s -&gt; next = L -&gt; next; L -&gt; next = s; scanf(&quot;%d&quot;, &amp;x); &#125; return L;&#125; 3. 双链表 结点定义 与单链表的区别是双链表多了一个 prior 指针，指向上一个结点，形成双向的链式结构。 12345typedef struct DNode&#123; //&quot;D&quot; 指 &quot;double&quot; ElemType data; struct DNode *prior; //指向前驱结点 struct DNode *next;&#125;DNode, * DLinkList; 双链表建立 与单链表相似，要注意的是头结点的 prior 指针永远指向NULL。 双链表的基本操作 插入： 与单链表相同，但要让新结点的prior指向其下一个结点的前驱结点，再令下一个前驱结点的 prior 指向新结点本身。 函数传入两个参数（DNode *p, DNode *s）；指在 p 结点后插入 s 结点。 注意判断边界条件及参数合法性（NULL） 删除后继结点： 判断参数合法性，参数传入（DNode *p）；指删除 p 结点后的结点。 判断 p 是否有后继节点 判断 p 的后继节点是否有后继节点，以决定是否修改其prior指针。 free 销毁双链表 持续对头结点的 next 进行 删除后继结点 操作，直到其 next 为 NULL。 删除 头结点 L 。 遍历 1234567891011//后向遍历while(p != NULL)&#123; //func p = p -&gt; next;&#125;//前向遍历while(p != NULL)&#123; //func p = p -&gt; prior;&#125; 只处理数据节点可直接跳过头结点，判断条件改为（ p -&gt; next != NULL） 循环链表 分为循环单链表和循环双链表 再一次套娃，首尾相连。 静态链表 静态链表定义 分配一片连续的存储空间，结点集中存储，其游标充当指针的作用。 12345#define MaxSize 10typedef struct &#123; ElemType data; int next; //仅需存储下一个元素的数组下标&#125;SLinkList[MaxSize]; 其它 尾结点的指针值为 -1 找到某一位序结点的时间复杂度为O(n) 初始化应抹除脏数据 与OS 的文件分配表( FAT )关联 顺序表与链表的比较 顺序表 链表 容量弹性 就这？ NB 增、删 就这？ NB 查 NB 就这？ 开放式问题答题思路： Q：请描述顺序表和链表的#@%，实现线性表时，用顺序表还是链表好？ A： 逻辑结构都是线性结构 存储结构不同 +（各自特点、优缺点） 基本操作效率不同（初始化、增删改查） 结论","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lapplandsp.github.io/LapplandSP/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"【数据结构·零】 算法","slug":"【数据结构·零】 算法","date":"2022-06-14T15:21:42.000Z","updated":"2022-06-18T07:46:35.946Z","comments":true,"path":"2022/06/14/【数据结构·零】 算法/","link":"","permalink":"https://lapplandsp.github.io/LapplandSP/2022/06/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E9%9B%B6%E3%80%91%20%E7%AE%97%E6%B3%95/","excerpt":"","text":"第一章 算法 1. 基本概念 程序 = 数据结构 + 算法 数据结构是要处理的信息 算法是处理信息的步骤 算法的五个特性 有穷性：一个算法必须在有穷步之后结束，且每一步的时间都是有穷的。 算法必须是有穷的，而程序可以是无穷的。 确定性： 算法中每条指令都必须有确切的含义，相同的输入对应得出相同的输出。 可行性： 算法中描述的操作都可以通过已经实现的基本运算执行有限次实现。 输入 输出 “好”算法的特点 正确性：能正确解决问题 可读性 健壮性：能处理异常情况 高效率与低存储量需求： 省时（低时间复杂度） 省内存（低空间复杂度） 2. 时间复杂度 计算 找到一个基本操作（最深层循环） 分析该基本操作的执行次数与问题规模n的关系 x = f(n) x 的数量级 O(x) 就是算法时间复杂度 T(n) 常用技巧 加法规则：O( f(n) ) + O( g(n) ) = O( max( f(n), g(n) ) ) 乘法规则：O(f(n)) * O(g(n)) = O( f(n) * g(n) ) O(1) &lt; O(log2n) &lt; O(n) &lt; O(n2) &lt; O(n3) &lt; O(2n) &lt; O(n!) &lt; O(nn) 常对幂指阶 顺序执行的代码只会影响常数项，可以忽略。 只需挑循环中的一个基本操作，分析他的执行次数与n的关系。 如果有多层嵌套循环，只需关注最深层循环循环了几次。 三种时间复杂度 最坏时间复杂度：考虑输入数据“最坏”的情况 平均时间复杂度：考虑所有输入数据都等概率出现的情况 最好时间复杂度：考虑输入数据“最好”的情况 3. 空间复杂度 计算 普通程序 找到所占空间大小与问题规模相关的变量 分析所占空间 x 与问题规模 n 的关系 x = f(n) x 的数量级 O(x) 就是算法空间复杂度 S(n) 递归程序 找到递归调用的深度 x 与问题规模 n 的关系 x = f(n) x 的数量级 O(x) 就是算法空间复杂度 S(n) 有的算法各层函数所需存储空间不同，分析方法略有区别 大部分递归调用都是 空间复杂度 = 递归调用的深度 常用技巧 加法规则、乘法规则、常对幂指阶 S(n) = O(1) 的常数阶算法可以原地工作","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lapplandsp.github.io/LapplandSP/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}],"categories":[],"tags":[{"name":"数据结构 算法","slug":"数据结构-算法","permalink":"https://lapplandsp.github.io/LapplandSP/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://lapplandsp.github.io/LapplandSP/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Markdown","slug":"Markdown","permalink":"https://lapplandsp.github.io/LapplandSP/tags/Markdown/"}]}